tema 04
El software a instalar está en la página https://gist.github.com/Klerith/4a4abfd88a88b2d1f16efd95fea41362
instalo:
React Developer Tools, extensión de chrome
Redux DevTools, extensión de chrome
visual studio code
postman
mongo compass que es para gestionar base de datos mongo
git 
node
añadimos activitus Bar  para visual studio code, para poner la barra abajo
Temas que estoy usando en VSCode:
Monokai Night

Tokyo Night

Iconos

Instalaciones recomendadas sobre React
ES7 React/Redux

Simple React Snippets

Auto Close Tag
Tema 8
React es una librería declarativa, es muy eficiente solo renderiza lo que cambia.
Permite tener componentes con estados o no, así tenemos piezas más pequeñas.
Se puede usar en back, con movile

La mínima aplicación sería esta:

Esta linea de java script busca el elemento con nombre root
const divRoot = document.querySelector("#root')
En esta línea react escribe en ese elemento el hml indicado.
ReactDom.render(<h1>Hola Mundo</h1>), divRoot);

A esto se le llama JSX que mezcla js y xml


lo anterior podría escribirse sólo así

const h1Tag = document.createElement('h1',null,'Hola Mundo')

Tema 9
Crea una carpeta 01-intro-react crea un index.html dentro
Escribe ! y luego ctrl y le sale un html básico
vamos a https://gist.github.com/Klerith/b0111f52ba16451d095f38d4c995605b y copiamos 

    <!-- Cargat React -->
    <script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

añade 
const h1Tag = <h1> Hola, soy  { nombre } </h1>;
pero da error porque esto no es javascript sino jsx, mezcla de javascript y html
para que no de error le debemos decir a babel que lo traduzca a jsx:

<script type="text/babel">
</script>

Tema 10
Explica babel que sirve para que traduza un código javascript moderno a un javascript normal, para que los
navegadores funcione.

Sección 3 Conceptos de javascript
Tema 11
¿Qué aprenderemos en esta sección?

Generar la base sobre JavaScript
Constantes y variables Let
Template String
Objetos literales
Arreglos
Desestructruación * (sumamente importante)
Promesas
Fetch API
Ternarios
Async - Await
Mi objetivo aquí es que tengamos las bases que nos ayuden a que podamos diferenciar fácilmente qué es propio de React y qué es propio de JavaScript. Estos conceptos y ejercicios nos ayudarán a suavizar la curva de aprendizaje de React.

Tema 13
Explica como crear el esqueleto de una aplicación react,
desde esta página https://create-react-app.dev/.
Existe otro proyecto que hace algo similar se llama vite https://vitejs.dev/guide/ (npm create vite@latest)
nos indica que ejecutemos en la linea de comandos el comando:
 npx create-react-app 02-intro-javascript
esto nos crea una carpeta con todo lo necesario para nuestra aplicación react.
si npx no está instalado node nos pregunta que lo instalemos
a mi me pide conectarme a github, lo hago y se instalado
luego aho cd a 02-intro-javascript y me abre un servidor node y un navegador que apunta a http://localhost:3000/

Tema 14
explica variables y constantes.
Declaración de variables:
const son variables que no se van a cambiar
let  son variables que cambian de valor.
var ya no se usa.

crea un index.js que luego copia y renombra en la carpeta bases a 01-const-let.js
El original lo deja vacio

Tema 15 Template String

sirve para poner concatener strings, poner variables dentro de strings etc..
El template string son los que van entre el simbolo `, dentro podemos mezclar
strings y javascript. El java script va dentro de ${}, además si hacemos
saltos de linea estos se incorporan al string.

const nombreCompleto = `${nombre} ${apellido} ${1+1}`;

Al final hace una copia en bases con nombre 02-template-string.js

Tema 16 Objetos literales

un objeto en javascript van entre llames
const perona = {

};
tenemos el objeto persona. Le ponemos propiedades

const persona = {
    nombre: 'Toni',
    edad:45,
}

console.log( { persona }) --> estamos creando un objeto nuevo que tiene 
una propiedad persona
console.table (persona)

const persona2 = persona;

hace una copia de referencia.

const persona2 = { ...persona};

hace una copia por valor

Tema 16 Arreglos
Es una colección de información dentro de una variable

const arreglo = new Array();

const arreglo = [];
arreglo.push(1);
arreglo.push(2);
El console.log los muestra con [], cuando es un objeto es {}
Para poner valores se puede usar push, 

Hace uso de nuevo de ..., que es lo que llama operador spread. 
Este operador lo que hace es leer el objeto que le acompaña y copiarlo parte a parte.

Dice que consultemos la página 
https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/map

Explica el método map de los arreglos.
Este método lo que hace es dada una función, la aplica sobre cada elemento del arreglo
origen y genera un nuevo arreglo con los nuevos valores:

por ejemplo una copia podría hacerse:

const arreglo3 = arreglo2.map(function(valor){return valor});

una copia con el doble del valor original

const arreglo3 = arreglo2.map(function(valor){return 2*valor});

una copia que sólo tendría tantas veces la palabra hola, como elmentos
tenga el arreglo original
const arreglo3 = arreglo2.map(function(){return 'hola'});



Tema 18 Funciones

function saludar (nombre) {
    return `Hola, ${nombre}`
}

console.log(saludar('Oscar'))

Aconseja que la definamos como Constante, así no la podemos machacar:

const saludar = function(nombre) {
    return `Hola, ${nombre}`;
}

Ahora explica la función de flechas

const saludar2  = (nombre) => {
    return `Hola, ${nombre}`;
}

si la función sólo hace un return se puede hacer esto

const saludar2  = (nombre) => `Hola, ${nombre}`;

y si no tiene parámetros

const saludar4 = () => `Hola, ${nombre}`;

cuando retornamos un objeto tenemos que poner un parentesis

const getUser = () => ({uid:'ddd',username:'ppp'})

Tema 19 Desestructruación de Objetos o Asignación desestructurante

dice que miremos esta página
https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment

Significa sacar los valores de los campos de un objeto de forma fácil.

Dado el objeto:

const persona = {
    nombre: 'Tony',
    edad: 45,
    clave: 'Ironman',
}

podemos sacarlo:
console.log(persona.nombre);
console.log(persona.edad);
console.log(persona.clave);

const { nombre, edad, clave} = persona;
console.log(nombre);
console.log(edad);
console.log(clave);

y si queremos renombrar algún campos

const { nombre:nombre2, edad:edad2, clave:clave2} = persona;
console.log(nombre2);
console.log(edad2);
console.log(clave2);

y si queremos coger los campos de dentro de un objeto que es un objeto se 
puede hacer de dos maneras:

const { nombreClave, anios, latlng: { lat, lng}} = persona;

o bien

const { nombreClave, anios, latlng} = persona;
const { lat, lng} = latlng;

cuando ponemos los : estamos diciendo que cree variables con el nombre de lo que 
hay a la derecha de los :. Por ejemplo

const {nombreClave:minombre, anios:misAnios, latlng: {lat,lng}} = avenger;
console.log(minombre, misAnios);
console.log (lat,lng);

Tema 20. Desestructruación de arreglos

Es sacar los valores en variables de un arreglo

const personajes =['Goku','Vegeta','Trunks']

const [  ,personaje2,personaje3 ]=personajes;

console.log(personaje2 personaje3);


const retornaArreglo = () => {
    return ['ABC',123];
}

const arr = retornaArreglo();
const [letras, numeros] = retornaArreglo();
console.log(letras,numeros)

//Tarea
//1. el primer valor de arreglo se llamará nombre
//2. el segundo se llamara setnombre
const useState = (valor) => {
    return [valor, ()=>{console.log('Hola Mundo')}]
}

const [nombre,setNombre] = useState('Goku');
console.log (nombre);
setNombre();

Sección 3. Tema 21

Nos pide crear un fichero en el directorio data con nombre heroes.js
que es un arreglo y contenido lo de este link 
https://gist.github.com/Klerith/4aeb99d31aedbc29ff4d54bbb77d2d7f

desde index.js quiere acceder:

import {heroes} from './data/heroes'

//pero para que funcione en heroes.js tenemos que poner un export

//Proponer hacer un ejercicio para que hacer que el siguiente código funcione,
//consultado el enlace : https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/find
const getHeroeById = (id) => {
    return heroes.find((elemento) => {
        console.log('id:', id);
        console.log('elemento:', elemento);
        return id===elemento.id});
}

console.log( getHeroeById(2))

//mejorado 

const getHeroeById2 = (id) => heroes.find((elemento) => id===elemento.id);


console.log( getHeroeById2(2))

//Ahora propone hacer funcionar el siguiente código, el caso es que el
// find no nos sirve porque ahora retornaremos más de un valor 
// dice que miremos la documentación para usar el Filter


const getHeroeByOwner = (owner) => heroes.filter((elemento) => owner===elemento.owner);

console.log( getHeroeByOwner('DC'));


arr[1]();

vuelve al tema de la exportación

dice que dado que el fichero sólo tiene la tabla
en lugar de exportarlo así:
export const heroes = [

e importar así:
import {heroes} from './data/heroes'

se puede poner

export default [

e importar así

import pepito from './data/heroes'

pero no le gusta

prefiere poner al final del fichero
export default heroes; al final del fichero
con export const heroes = [

otra cosa sobre la exportación, es cuando se exporta más de una cosa
y una de ellas es por defeco, entonces en la de importar
la que no tiene llave es la de por defecto y además podemos poner
el nombre que queramos en la importación directamente.
Si no es por defecto podemos cambiar el nombre así
import {heroes,owners as otro nombre} from './data/heroes'

export const owners = ['DC','Marvel];
export const heroes= ['DC','Marvel];

su import sería
import {heroes,owners} from './data/heroes'

si hacemos una por defecto, entonces no se ponen llaves

const heroes = ['DC','Marvel];

export const owners = ['DC','Marvel];
export default heroes;

import heroes,{owners} from './data/heroes'

también es análogo 

export {
    heroes as default,
    owners,
}


Sección 3 Tema 23 Promesas

const promesa = new Promise();

son asincronas, se ejecuta después de lo sincrono.

Indica la documentación a revisar: https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Promise

Las promesas recibe de parámetros que son callback.
El primero se ejecuta cuando este ok, y el segundo cuando falle

const promesa = new Promise ( 
    
    (resuelto,noResuelto) => {
    
        setTimeout(() => {
            resuelto();    
        }, 2000);
    
        ;
    }
)
//si pongo la llamada al método resuelto, que no está definido 
//la promesa no se cumple y el método then nunca se ejecuta

promesa.then( () =>{
    console.log('Then de la promesa')
})

Ahora pide que dentro del setTime haga un

const heroe = getHeroById(2);
console.log(heroe);

Ahora explica como pasarle argumentos a  la promesa. Esto
se hace poniendo la definición en la promesa dentro de una función

const miWrapper =(parametro) =>{
   return new Promise ( 
    
    (resuelto,noResuelto) => {
    
        setTimeout(() => {

            const heroe = getHeroeById(parametro);
            //console.log(heroe)
            resuelto(heroe);    
        }, 2000);
    
        ;
    }
)
}

miWrapper(3).then( p1 => console.log('Heroe',p1));

Ahora pide que añadamos el caso de error, y será cuando 
busquemos un indice que no existe

const miWrapper =(parametro) =>{
   return new Promise ( 
    
    (resuelto,noResuelto) => {
    
        setTimeout(() => {

            const heroe = getHeroeById(parametro);
            console.log('Dentro', heroe)
            if (heroe)  resuelto(heroe);
            else noResuelto(heroe);    
        }, 2000);
    
        ;
    }
)
}

miWrapper(2).then( p1 => console.log('Exito',p1))
.catch(p1 => console.log('Error',p1))

Comenta que podemos evitar escribir esto así

miWrapper(2).then( p1 => console.log('Exito',p1))
.catch(console.warm)

poniendolo así, dado que como sabemos que recibimos un sólo
parámetro y a la función le pasamos uno solo, javascript ya 
sabe lo que tienen que hacer

 //pide hacer lo mismo con el then
 miWrapper(2).then( console.log)
 .catch(console.warn)

 Sección 3. Tema 24 Fetch API

 es una librería interna, no hay que importar nada, recomienda
 leer esta página https://developer.mozilla.org/es/docs/Web/API/Fetch_API

 y para el ejemplo usaremos la siguiente web para disponer de una 
 api a la que llamamos y nos devuelve gifs que es esta:

 https://developers.giphy.com/ me doy de alta en la web con
 usuario rak0kso@gmail.com/rakG1kso

 creamos una aplicaicón tipo api, y nos quedamos con la apikey

 GeBZZMWXwYjyH2H5CxCKkZtXE2frfBzL

 buscamos en la documentación las api y cogemos la api Random EndPoint

 api.giphy.com/v1/gifs/random	

llamada de ejemplo 
https://api.giphy.com/v1/gifs/random?api_key=GeBZZMWXwYjyH2H5CxCKkZtXE2frfBzL

dado que fetch es una promesa que cuando se ejecuta ok nos devuelve 
la respuesta de la invocación a la url que le pasamos como argumento.
En el then le pasamos una función que coge esa respuesta y la devuelve en formato json.
Este formato json, también es una promesa que cuando se ejecuta nos devuelve
el forma json. Con ello cogemos la url de la imagen y la pintamos.

Sección 3 tema 25 Async Await

El Async hace que lo que se ejecute pueda ser sincrono.
El Await va siempre dentro del Async y con ello indicamos que el flujo
de ejecución se espere hasta que la sentencia se acabe.
Si ponemos el Await delante de la ejecución de una promesa conseguimos 
que esta sea sincrona.
Al hacer esto no hace falta que escribamos el then, ya nos retorna lo que calcula
la promesa.
Las promesas tenian el then para cuando iba ok, el catch cuando acaban ko, y el finally
para siempre. 
Cuando las ejecutamos de forma sincrona, para recoger los errores tenemos que
poner todo dentro de un try catch
Ahora lo que hace es reescribir el código del tema anterior, 
pero para que quede sincrono

Sección 3. Tema 26  Operación Ternarios

Es una forma corta de hacer un if.

const activo = true;

let mensaje = '';

if (activo) {
    mensaje = 'Activo';
} else {
    mensaje =' Inactivo';

}

console.log(mensaje);

se rescribe

const mensaje = (activo) ? 'Activo' : 'Inactivo';

Si no tenemos el else sería así;

const mensaje = (activo)&& 'Activo'

Recomienda leer para javascript esta web https://developer.mozilla.org/es/
y hacer su curso "JavaScript moderno"

Luego pasa la url del código que ha hecho 
https://github.com/Klerith/react-intro-javascript

Sección 4. Tema 1 introducción

¿Qué veremos en esta sección?

Nuestra primera aplicación - Hola Mundo

Exposiciones sobre los componentes

Creación de componentes (Functional Components)

Propiedades - Props

Impresiones en el HTML

PropTypes

DefaultProps

Introducción general a los Hooks

useState

Es una sección importante, especialmente para todos los que están empezando de cero en React, ya que dará las bases de cómo segmentar la lógica de nuestra aplicación en pequeñas piezas más fáciles de mantener.

Sección 4 Tema 32
Ahora crea la aplicación de ejemplo con create vite 

ejecuta dentro de la carpeta I:\udemy\repogit\cursoReact\udemy-react-de-cero-a-experto-hooks-y-mern
yarn create vite
pide un nombre de proyecto y le pone counter-app
pide que framework y le dice react

cuando acaba tenemos una carpeta que se llama counter-app
la renombra 03-counter-vite

luego ejecuta en ellas
yarn -->Esto instala las dependencias del proyecto
yarn dev


Nota: He tenido que crear instalar yarn
que se instala via npm: npm install --global yarn

usa yarn para dependencias locales y npm para dependencias globales ¿?
luego hacer lo mismo con create react
npx create-react-app counter-app

este es mas lento por que usa webapp para actualizar los componentes, y vite
utiliza otra  cosa
renombra la carpeta 03-counter-cra 

Sección 4 Estructura aplicación cra

se ve que fue creado por npm porque tiene el fichero package-lock.json
se crea con el npm install
en el package.json hay infomración interesante, como dependencias, el nombre del
proyecto, etc..

La carpeta public tiene el index.html que es donde se invocará  a nuestra aplicaicón

robots.txt es un fichero que usa google para analizar nuestra aplicación.
explicación de robots : https://developers.google.com/search/docs/crawling-indexing/robots/intro?hl=es&visit_id=638282342332022604-3099763398&rd=1

también pone estos dos enlaces
PWA Progressive web app: https://web.dev/learn/pwa/
ayuda de cra --> https://create-react-app.dev/docs/available-scripts/
app.js --> tiene el javascript
index.js --> es realmente un jpx, tiene html y javascript


Sección 4 Directorios de vite

tiene el package.json
yarn.lock indica que lo creamos con yarn.
tiene un main.jsx que es análogo al index.js

Sección 4 Tema 35 primera aplicación en react

usa carpeta de vite,
arranca la aplicación con yarn dev

borra todo lo del source y crea un fichero main.jsx
importa react, react-dom/client

todo en react funciona con componentes funcionales

function App() {
    return (<h1> hola Mundo</h1>)
}

ReactDOM.createRoot(document.getElementById('roo')).render(
    <React.StrictMode>
    <App/>
    </React.StrictMode>
)

Sección 4 Tema 35 crear primer componetente
el componente app lo había creado dentro del main.jsx, pero lo mueve a otro fichero
Crea un fichero HelloWorldApp.jsx
Mueve la función la exporta de forma unitaría y la importa.

Sección 4 Tema 36 tarea crear nuevo componente

Ahora propone que el componente no solo escriba un h1 sino que haga más html.
pero si ponemos dos lineas falla.
La primera solución es ponerlo todo dentro de un div, pero si lo ponemos dentro del div
nos genrará un div no deseado en la página
React permite enviar n sentencias con el tag <Fragment>

hace lo siguiente 
import {Fragment} from 'reac';

export const FirstApp = () => {
    return (
        <Fragment><h1>Hola</h1><p>subtitulo</p></Fragment>
    )
}

react permite hacer esto sin declararlo pero usando <>

export const FirstApp = () => {
    return (
        <><h1>Hola</h1><p>subtitulo</p></>
    )
}

Sin el import. React sólo permite retornar un nodo.

Sección 4 Tema 39 Impresión de variables en el HTML

Como pones javascript dentro del html se hace con {} siempre que 
el javascript no sea un objeto.

<h1>hola { 1*5 }</h1>
 o
 <>{1*5}</>

 el código javascript, debe estar fuera de la función del componente por Temas
 de rendimiento

Sección 4 Tema 40 Añadir estilos

crea un styles.css con
html, body {
    background-color: #021232A
    color: white
    font-falimy: Helvetica, Arial, sans-serif;
    font-size: 1.3rem;
    padding: 70px;
}
y luego en el main.jsx importa el fichero con 
import "./styles.css";

Sección 4 Tema 41 comunicación entre componentes - Props

son los parámetros que le podemos definir al a funcion que renderizan

Los parámetros siempre son un objeto por tanto quedaría

export const FirstApp = ( prop) =>

return <>
<h1>{prop.titulo}</h1>
</>

y en la llamada <FirstApp titulo="Hola Mundo"/>

además explica que en f12 en la pestaña de components podemos ver el parámetro y 
modificarlo

Sección 4 Tema 42 PropTypes

Es una funcionalidad que viene directa con cra y no con vite
El objetivo es hacer parámetros obligatorios.

import PropTypes from 'prop-types';
yarn add prop-types o npm install prop-types

Luego declara 

FirstApp.propTypes = {
    title : PropTypes.string; Indica que debe ser un string, provocando un warning por consola.
    title : PropTypes.string.isRequired; Indica que debe ser un string, provocando un warning por consola.


}

Sección 4 Tema 43 Default PropTypes

Podemos poner valores por defecto en la definición del functional componente

export function FirstApp( {titulo='vacio', subtitulo='subtitulo vacio', valor})

o bien podemos usar una propiedad de este que se llama defaultProps de la siguiente
manera para nuestro ejemplo.

FirstApp.defaultProps = {
    title: 'No hay título',
    subTitle: 'No hay subtitulo'
    nuevo:'Nuevo'
}

Sección 4 Tema 44 Tarea - ComponentCounter

Pide hacer el ejercicio que está en esta url:
https://gist.github.com/Klerith/e1a731cc595c00a9794a709062eae757

Sección 4 Tema 45 Evento Click

En react los eventos son unos objetos sinteticos que 
encapsulan los eventos de los navegadores y los homogenizan
para que se comporten en todos los navegadores igual.

En la pagina siguiente hay documentación : https://es.react.dev/reference/react-dom/components/common#react-event-object


Ahora añade un botón al componente que al recibir un onclick llama a una función

Comenta que la función si no hay referencia a nada del componente la podemos 
poner fuera, y eso hara el componente más ligero porque no la volverá a leer.
No necesitamos que se lea porque es una función que no cambia.

Explica que si en la función tocamos el parámetro que le llega al componente.
y lo pintamos veremos que no pasa nada. Esto es porque react aunque cambie
el valor del parámetro no lo redibuja porque no le hemos dicho que lo redibuje.
En cambio si hacemos un console.log el parámetro si cambio de valor.

Sección 4 Tema 46 useState

Habla de los hooks, hay muchos y en el fondo son funciones.
Comenta el useState que es un hook.
Los hooks aparece a partir de la versión 16.8
Comenta la documentación: https://es.legacy.reactjs.org/docs/hooks-intro.html

Los hooks cuando cambian provocan que se renderice, en el ejemplo anterior
aunque se incrementaba el valor no lo veíamos en la página porque react
no consideraba que había un cambio, los hooks hacen que react reconozca el cambio.

Los hooks puede ser de react o custom. De react hay unos cuantos y todos 
empizan por use: useState, useContext, use....

useState recibe un valor inicial del estado
y devuelve un valor final y una función a la que llamaremos 
para cambiar el valor.

const [ contador, actualizaContador ] = useState ( valorInicial);

actualizaContador(contador + 1)



Cada vez que cambia el estado se vuelve a ejecutar todo el functional component,
es decir la función CounterApp

Se puede demostrar poniendo un console.log en el componente,

Hacemos la función:

function restar(event) {
        console.log(event);
        //da error porque contador es una constante contador=contador +1;
        actualizaContador(contador -1);
        console.log(contador)
    }   


que se puede reescribir por
const restar = () ==> actualizaContador(contador -1);

Parece que el useState tiene acción después cuando se renderiza el componente.
Es decir, inicialmente el contador vale 2, si clico sumar 1, después de 
la función sumar 1, vale 2 igual que antes, pero después se renderiza el componente
pero ya con el nuevo valor 3.
Esto es así porque el useState es asincrono y el valor no se actualiza hasta que 
pasa un tiempo. 
Si se pone un dealy en el console.log se ve bien.

Tema 48 código de la sección
https://github.com/Klerith/react-vite-counter-app/tree/fin-seccion-4

Sección 5 Pruebas unitarias

¿Qué veremos en esta sección?

Introducción a las pruebas

AAA

Arrange - Arreglar

Act - Actuar

Assert - Afirmar

Primeras pruebas

Jest

Expect

toBe

Enzyme

Comandos útiles en la terminal para pruebas

Revisar elementos renderizados en el componente

Simular eventos

Esta sección de pruebas es sumamente importante porque nos dará la base de las pruebas que estaremos haciendo durante el curso, las pruebas irán creciendo en complejidad, por lo que les recomiendo que nos aseguremos de comprender bien todos estos conceptos para que nos sea más fácil las siguientes secciones de pruebas.

Sección 5. Tema 51 introducción

Arreglar: 
es incializar
Actuar:
aplicamos acciones
Afirmar:
observar el componrtamiento de las acciones

Tema 52
nos hace poner en src el código del tema 52 que es el de la primera parte del curso
template-string, funciones etc...

Sección 5 Tema 53
´
Como usamos vite tenemos que configurar las librerias de testing,
si vuer cra no haría falta.
Nos enseña la web de jest https://jestjs.io/
yarn add --dev jest
luego en package.json
añade el script test.

luego ejecuta yarn test
nos dará error porque no tenemos pruebas

Crea un directorio test en el src, y hace un espejo de los ficheros 
si tenemos un CounterApp.jsx tendremos un ConteerApp.test.js
le damos contenido

el fichero se llama demo.test.js, sino acaba con test.js no lo reconoce.

test('Esta prueba no debe falla', ()=>{

    aqui evaluamos cosas
})

Ahora tendría que ejecutar yarn test cada vez.
para que se ejecute en cada cambio  en el script ponermo 

yarn jest --watchAll

Tema 5 Tema 54

consultar documentación jest

Jest nos ayuda no hacer if en el codigo de test.

const message1 = 'Hola mundo';
const message2 = message1.trim();

en lugar de hacer
if (message1 === message2) throw exception

hariamos 
expect (message1).toBe(message2);

como el jest tiene muchos metodos y añade
yarn add -D @types/jest instala en desarrollo y el visual studio ya nos ayuda 

Sección 5 Tema 56
Ahora va a añadir test al archivo 02-template-string, para poder llamar a una
función que queremos testear tenemos que hacer un export de esta.
Además quita las otras varibles del archivo.

Crea un archivo espejo para probar la función.

No funciona porque jest no interpreta babel, tenemos que instalarlo y configurarlo

yarn add --dev babel-jest @babel/core @babel/preset-env

luego tocamos el fichero babel.config.js como dice la documentación
 https://jestjs.io/es-ES/docs/getting-started

 explica como hacer que no se ejecuten todos los archivos de test sino 
 solo el que estamos trabajando

 en yarn jest -watchAll
 clickamos w

 pero tuve que poner eston en powershell como administrador
 Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
 y el regexpr no me funciona

 Sección 5 Tema 57

 ahora hace test que comparan objetos java sobre el 05-funciones.
 se hace con expect ... toEqual

 Sección 5 Tema 58
 Hace un test que comprueba que devuelve un string o un número.
 explica que hay dos formas de hacerlo.
 una con typeof de javascript 

 expect(typeof miValor).toBe('String')

 o bien con puro jest que es un objeto cualquiera pero string.

 except ( mivalor).toEqual(expect.any(String));
 Sección 5 Tema 59
 Mas test ahora del fichero 08

 Sección 5 Tema 60
 Pruebas sobre las promesas 09

 Jest ejecuta todo secuencial, por lo que cuando ponemos una promesa, no espera que esta se ejecute

  const id = 1;
        getHeroeByIdAsync(id).then( heroe => {
            console.log('hola:', heroe);
            expect(true).toBe(false);
        }
        
        );
        console.log('adios')

Esta prueba pasa, escribe adios, no escribe hola, y cuando acaba dice que hay un worker fallado, se da cuenta
que hay cosas que no ha ejecutado.

 para que no lo haga, debemos pasarle un nombre
 que normalmente se le pone el nombre de done, el cree que es una función que llamará
 asumiendo que ha acabado,
 así que en lugar de poner 

 
 test('getHeroesByOwner debe retornar heroes de DC',()=>{
    ponemos
test('getHeroesByOwner debe retornar heroes de DC',(hecho)=>{
y en la promesa llamamos a hecho.

Con este test

   test('getHeroeByIdAsyncdebe retornar un heroe por i',(CuandoHecho)=>{

        const id = 1;
        getHeroeByIdAsync(id).then( heroe => {
            console.log('hola:', heroe);
            //expect(true).toBe(false);
            CuandoHecho();
        }
        
        );
        console.log('adios')

Sección 5 Tema 61 Pruebas async-await

 Cuando nosotros desde jest lanzamos :

  const url = async getImagen();

  se queja porque el async no lo reconoce, para que lo haga nos pide que hagamos  una serie de configuraciones.

  Para que funcione configura el jest. Para hacerlo, primero en el raíz crea un archivo llamado
  jest.config.js
  En este archivo declara una propiedad que se llama setupFiles con la que le indicamos un archivo (jest.setup.js)
  de javascript que debe ejecutar jest cada vez.
  En este archivo cargará los modulos que le permiten ejecutar el fetch que es lo que le molesta
  Antes instalamos via yarn este modulo para desarrollo con la opción -D
  yarn add -D whatwg-fetch
  en el fichero hace un import de este modulo
  import 'whatwg-fech';

Al final no he tenido que configurar nada, solo poner el async en la llamada

Al hacerlo la salida es así
 const id = 1;
        getHeroeByIdAsync(id).then( heroe => {
            console.log('hola:', heroe);
            expect(true).toBe(false);
        }
        
        );
        console.log('adios')


Sección 5 Tema 63
react testing library, es otro framework de testing
le gusta jest pero también quiere usar testing library porque es muy bueno para componentes
De hecho en la documentación de jest recomienda el uso de react testing library y dice como
instalarlo (https://jestjs.io/docs/tutorial-react#dom-testing, https://testing-library.com/)
yarn add -dev @testing-library/react

Sección 5 Tema 64
Ahora creamos un test para firstapp y en el test invocamos al render
de import { render } from '@testing-library/react'
pero da un error porque no sabe hacerlo para arreglarlo hace
en el jest.config.js añade
testEnvironment: 'jest-environment-jsdom',
e instala yarn add -dev jest-environment-jsdom
y en el babel.config

presets :[
    [@babel/preset-react',{runtime :'automatic'}]
]

e instala @babel/preset-react 
con yarn add -D @babel/preset-react

no me ha funcionado no lee el archivo jest.config.cjs, al final en el test 
he puesto lo siguiente

  /**
 * @jest-environment jsdom
 */

 para que pueda renderizar
 Tema 5 sección 65
 explica que el render nos ofrece un container y funciones.
 El container contiene el código html que genera el componente.
 Las funciones son funciones para buscar dentro del componente.
 También explica que es muy útil hacer un snapshot de lo que genera
 el componente esto se guarda en una carpeta y el test 
 comprueba que lo generado por el render es lo mismo. Si no lo es
 avisa e indica si queremos actualizar el render.
 el snapshot lo genera al ejecutar esta linea
  expect ( container ).toMatchSnapshot();
  jest guarda una foto y la comporar cada vez.


  Sección 5 Tema 66 getByTestId

Ahora del render coge la función getByTestId
En el código generado por el componente le pone un atributo
donde quiere con nombre data-testid="test_1" y luego con la función
getByTestid puede recuperar ese valor así, hacemos la prueba flexible.
No debe estar en un h1 sino en un sitio con este valor

Sección 5 Tema 67 screen

igual que el render, tenemos el screen que es el código html 
de la página, se dedica a hacer los mismos test pero usando el screen

Sección 6 Tema 68 Pruebas CounterApp
Ahora poque para que se renderice solo el CounterApp
pide que hagamos las pruebas de:
debe de hacer match con el snapshot
debe mostrar el valor inicial de 100

Sección 6 Tema 69 Simular eventos

Lo hace con fireEvent para disparar eventos.
podemos simular cualquier evento, simula el click sobre un
elemento de lo generado via screen

fireEvent.click(screen.getByText('+1'))
expect(screen.getByText('101')).toBeTruthy();

con screen.debug() nos mostrará como está el dom por pantalla

usa el atributo arial-label y luego lo usa
fireEvent.click(screen.getByRole('button',{name:'bnt-reset'}))

Sección 6 Temas
¿Qué veremos en esta sección?

Custom Hooks

Fetch hacia un API

Comunicación entre componentes

Clases de CSS

Animaciones

Enviar métodos como argumentos

Crear listados

keys

Giphy

Esta es una aplicación pequeña pero muy ilustrativa que explica cómo utilizar React + customHooks para poder resolver necesidades en específico que podremos re-utilizar después.

Sección 6 Tema 74

Crea una app
yarn create vite --> crea la aplicación
yarn install --> instala los modulos apm
yarn dev --> arranca


Sección 6 Tema 75
Añade estilos y explica como organizar los ficheros


https://es.legacy.reactjs.org/docs/faq-structure.html
https://hackernoon.com/structuring-projects-and-naming-components-in-react-1261b6e18d76

Sección 7 Tema 77
Crea una lista de tareas de categorias con ol, y la llena un useState
React guarda cada hook como una lista numerada y sabe cual es cual por el orden
en el que aparecen. 
Si declaramosun hook (useState) dentro de un if, esto va encontra de react.
No se debe hacer nunca
Sección 6 Tema 78
Hacer un boton que añada tareas.
useState y react:
//setCategories([ 'categoria1','categoria2','categoria3'] ); --> esto hace un bucle
        //y no funciona, y esto también setCategories(ategories.push("categoria3") )
        // tampoco funciona 
        // categories.push("categoria3");
        // setCategories(categories);
        // por que a react no le gusta que le toques la variable de estado. El push lo que hace es añadir
        // un valor alos existentes, pare evitar eso hay que hacer una nueva copia, modificar la copia,
        // y asignarla con el set, así le creas un nuevo estado.
        // por seo la solución es setCategories([ ...categories, 'Nuevo valor']); el comando hace una copia, y añade
        // un nuevo valor. 

        /* 
        ...categories, saca los valores, y [,] añadem por tanto para añadirla nueva al principio hacemos
        setCategories(['NuevoValor, ...categories])
        */

Tema 78

Ahora escribe un componente que será una caja de texto.
Primero lo hace con un input y el estado de este input

const [ inputValue, setInputValue] = useState('nuevo valor');

return (
    <input
    type="text"
    value={inputValue}
)

Esto no funciona, cuando escribimos en el input no pasa nada, no nos deja escribir.
Para solucionarlo le pone un onchage

const [ inputValue, setInputValue] = useState('nuevo valor');

const onInputChage = () => {
    setInputValue('hola');
}
return (
    <input
    type="text"
    value={inputValue}
    onChange= {onInputChange}
)

Esto tampoco funciona ahora cuando escribimos cambia a hola mundo.
Tenemos que coger el valor de lo que ha cambiado y asignarlo al estado.

const [ inputValue, setInputValue] = useState('nuevo valor');

const onInputChage = (event) => {
    setInputValue(event.target.value);
}
return (
    <input
    type="text"
    value={inputValue}
    onChange= {(event) => onInputChange(event)}
)

Pero queremos que cuando le demos a enter haga algo para ello pone 
el input dentro de un form que llame a una nueva función

const [ inputValue, setInputValue] = useState('nuevo valor');

const onInputChage = (event) => {
    setInputValue(event.target.value);
}

const onSubmit = (event) => {

}

return (
    <form onSubmit={ (event)} => onSubmit(event)}>
    <input
    type="text"
    value={inputValue}
    onChange= {(event) => onInputChange(event)}
    </form>
)

Pero el form lo que hace es recargar la página, para evitarlo
debe hacer un event.preventDefault en la función que llame el formulario.

const [ inputValue, setInputValue] = useState('nuevo valor');

const onInputChage = (event) => {
    setInputValue(event.target.value);
}

const onSubmit = (event) => {
    event.preventDefault();
}

return (
    <form onSubmit={ (event)} => onSubmit(event)}>
    <input
    type="text"
    value={inputValue}
    onChange= {(event) => onInputChange(event)}
    </form>
)

optimizando

const [ inputValue, setInputValue] = useState('nuevo valor');

const onInputChage = (event) => {
    setInputValue(event.target.value);
}

const onSubmit = (event) => {
    event.preventDefault();
}

return (
    <form onSubmit={ onSubmit(event)}>
    <input
    type="text"
    value={inputValue}
    onChange= { onInputChange(event)}
    </form>
)

Para escribir rápido un componente escribe rafc

Tema 79

Ahora pide quitar el botón de añadir literal y que desde el componente añadamos elmentos a la lista
Como pista sugiere pasar la función setCategories al componente.

La idea era pasar la función del useState del componente principal al de debajo  e invocarla
asignando el valor que obtiene el componente que está leyendo la info, pero esto no funciona
//no funciona da error GifExpertApp.jsx:45 Uncaught TypeError: categories.map is not a function
        //functionAddCategory(...inputValue); 
        
Debemos llamarlo, pero no con el valor a introducir, sino con una función para que react
lo actualice correctamente se intenta explicar en esta página pero no me queda claro

https://es.react.dev/reference/react/useState#updating-state-based-on-the-previous-state

Dice que react no ejecuta la función inmediatamente, lo que hace es ponerla en cola resolviendo todos los valores que se le pasan
y luego la ejecuta secuencialmente.
Si hacemos que sea una función, entonces si que lo hace
de algún modo sabe que categories es el valor actual y lo debe actualizar con el input

En una respuesta el profesor dice
Recuerda que la función set (el segundo elemento del array que desestructuramos del useState, 
en este caso setCategories en el GifExpertApp.jsx) puede recibir como argumento un valor determinado para actualizar el estado o una función actualizadora, 
que tiene como argumento el estado previo.

Tema 80

Ahora tenemos el GifExpert que es el padre y tiene un hijo que es el addCategory.
El padre le pasa al hijo la función del useState y este tiene que saber que le están pasando un useStates.
En realidad lo correcto sería qu el hijo, donde delegamos la captura de una categoria no supiera nada y que devolviera el useState.


ahora lo que hace es al reves que el componente que tiene el input devuelva el valor
para ello invoca al componente que tiene el input pasandole una función del tipo (value) => onAddCategory(value) , que resumido queda como onAddCategory
y en el componente invocamos a esta función.


        functionAddCategory((categories)=> [inputValue,...categories])

La función que pasará ahora al hijo la llama onAddCategory,para darle la semantia que emite algo

onNewCategory={ (valor) => onAddCategory(valor)} es decir el hijo tiene una propiedad 
llamada onNewCategory que será una función a la que llamará.


81 Quiere evitar que enviemos 2 valores iguales
lo hace en el gifexpertapps

82
Creo un nuevo componente para mostrar la lista de categorias.
El componente se llama GifGrid, recibe como parámetro la categoria buscar
y renderiza los resultados de esa búsqueda.

83 Feth API obtener imágnes 

crea dentro del GifGrid una función que va a buscar la url del gif.
 y luego llama a esta función dentro del webcomponent.
 Esto hace que siempre se llame dos veces a la función.
 Nunca debemos poner dentro del webcomponent una función sino se ejecutará de forma
 incontrolada.

Para remediarlo se debe usar el useEfect
Para acabar mueve la función a otro fichero.

84 useEffect

React renderiza los componentes, funtional component cada vez que detecta un cambio.
Si dentro del componente tenemos una función esta se ejecutará de nuevo.
Además react en StrictMode ejecuta dos veces los componentes.

Para evitar que lo ejecute la segunda vez lo quitamos.
React.StrictMode
Este modo en produción no aplica.

Para eviatar que lo ejecute la primera vez usa el useEffect.
El useEffect se le pasa la función que queremos que se ejecute solo sobre algunas condiciones
y luego le pasa la lista de condiciones. si le pasamos una lista vacia asume que 
sólo se debe ejecutar cuando se crea el componente.

useEffect(() => {getGifs(category)},[])

La función llama a nuestro getGifs, cuando []

85 Demostración de un build a producción
el modo StrictMode lo hace react para validar y sólo lo hace en desarrollo.
Para generar el build de producción
yarn build
esto genera una carpeta dist que está el código a copiar a pro.
Luego lo copia en un httpserver y vemos que no se reptie la llamada

87 mostrar títulos de las imágenes



Quiere mostrar los títulos de las imágenes.
Dado que queremos que se refresque

cuando nosotros usamos el async estamos indicando que es una promesa.
el useEffect espera una función,no una promesa por ello desde el
useEffect no podemos llamar al getGifs para obtener los gifs de la categoria y
guardarlos en el useState.

Si desde la promesa llamamos directamente al getGifs como tiene un async implica que es una promesa,
y lo que pasa es que no acaba de ejecutarse, para mitigarlo lo que hace es hacer el then

 useEffect(() => {

    const newImages= getGifs(category);
    
  
    getGifs(category).then( newImages => setImages(newImages));
    
    //console.log("imagenes",newImages);
  },[])
El useEffect sólo puede tener una linea, si pongo dos no funciona ni aunque sea un console.log

luego para mejorarlo crea una función que hace todo esto:

const getImages = async() => {
    const newImages = await getGifs(category);
    setImages(newImages);
}

useEffect(() => {

    const newImages= getImages();
  
  
  },[])
https://react.dev/learn/state-a-components-memory
87 spread y componente gifItem
En jsx no se puede poner class para los css, se debe usar className
le pone la key al nuevo componente porque react se queja todo los componentes tienen que tener un id.
En esta clase crea un componente que será el encargado de pintar cada elemento de los gifs que hemos obtenido.
El componente se llama GifItem

para pasar los parámetros al componente usa lo que se llama spread

en lugar de escribir 
<GifItem
key= {image.id}
title={image.title}
url= {image.url}
/>

hace esto
<GifItem
key= {image.id}
{...image}
/>

88 CustomHook  useFetchGifs
Ahora para simplificar el componente GifGrid, crea un customHook
Un hook al final es una función y es lo que hace crea una función
que retorna un objeto con dos campos images y isLoading.
Esta función la crea en otro archivo js

89 Mostrar mensaje de cargará
a partir del customhook que retorna si está cargando o no.
{
    isLoading && ( <h2>Cargando...</h2>)
}

90 Archivos de barril

Explica la manera de hacer que podamos importar todos los componentes de una carpeta
para ello en la carpeta crea un archivo con nombre index.js
y contenido
export * from './addCategory';
export * from './GifGrid';
export * from './GifItem';

luego en el fichero se carga haciendo referencia al nombre de la carpeta
impot {GifGrid} from './components';


¿Qué veremos en esta sección?

Aprender cómo realizar backups a repositorios de Git

Subir nuestro repositorio a GitHub

Uso de Github Pages

Desplegar nuestra aplicación de React

Generar build de producción de nuestra aplicación   

94 Despliege en netlyfy
dice que hagamos yarn buil para generar la carpeta build.
dice que borremos el fichero .ignore
que hagamos yarn build para que genere la carptea dist
que vayamos a https://www.netlify.com/
creo una cuenta que la asocio  a gitlab
luego arrastro la carpet dist a netlify
https://rakkso.netlify.app/

95 Ahora habla de poner  código a git

git checkout -- . --> restaura el último commit

96 Ahora habla de subir códig a git

crea un repositorio en github
git remote add origin https:/.... del repositorio
git branch - M main renombra la rama a main, en lugar de master
git push  -u origin main --> -u dice que será el de por defecto y el main.

$ git remote -v
origin  https://gitlab.com/rakkso/udemy-react-de-cero-a-experto-hooks-y-mern.git (fetch)
origin  https://gitlab.com/rakkso/udemy-react-de-cero-a-experto-hooks-y-mern.git (push)

git remote set-url origin https://github.com/rakkso/curso-react.git

coge el dist le cambia el nombre a docs y hace un push
hace un push entonces se sube y luego en settings en github lo escoge
y así se despliega

les da errores de 404 y lo explica en la siguiente clase.

no encuntra los recurso para que lo haga el pone un . para que se path relativo 
en el html del docs.

no soy capaz de publicarlo, github me dice que los dominios que doy no son válidos.

101 Configurar las pruebas.
Nos pasa un git para configurar las pruebas


Instalaciones:
yarn add --dev jest babel-jest @babel/preset-env @babel/preset-react 
yarn add --dev @testing-library/react @types/jest jest-environment-jsdom
Opcional: Si usamos Fetch API en el proyecto:
yarn add --dev whatwg-fetch
Actualizar los scripts del package.json
"scripts: {
  ...
  "test": "jest --watchAll"
Crear la configuración de babel babel.config.js
module.exports = {
    presets: [
        [ '@babel/preset-env', { targets: { esmodules: true } } ],
        [ '@babel/preset-react', { runtime: 'automatic' } ],
    ],
};
Opcional, pero eventualmente necesario, crear Jest config y setup:
jest.config.js

module.exports = {
    testEnvironment: 'jest-environment-jsdom',
    setupFiles: ['./jest.setup.js']
}
jest.setup.js

// En caso de necesitar la implementación del FetchAPI
import 'whatwg-fetch'; // <-- yarn add whatwg-fetch

he tenido que cambiar la extensión de jest.config.js a jest.config.cjs 
y el de babel.config.js a babel.config.cjs

102 Implementación  PropTypes
Hacer los test de la ruta crítica
Tamibén tratar de probar los más pequeño

Tenemos que hacer la tarea de añadir proptyes a GifItem
evaluar que title  y url son obligatorios
Luego evaluar el snapshot

Para añadir PropTypes

Es una funcionalidad que viene directa con cra y no con vite
El objetivo es hacer parámetros obligatorios.

import PropTypes from 'prop-types';
yarn add prop-types o npm install prop-types

FirstApp.propTypes = {
    title : PropTypes.string; Indica que debe ser un string, provocando un warning por consola.
    title : PropTypes.string.isRequired; Indica que debe ser un string, provocando un warning por consola.


}

importamos un render
import { render } from '@testing-library/react'

    test('debe de hacer match con el snapshot',() =>{

        const titulo = 'Hola, Soy Goku'
        const {container } = render (<FirstApp titulo={titulo}/>);

        //console.log(container);
        expect ( container ).toMatchSnapshot();
    })


104 Añada más pruebas

para saber que está renderizando el render podemo usar despues
del render  el screen.debug y así nos muestra el código html generado por el render.
    test('debe de hacer match con el snapshot',() =>{

        const titulo = 'Hola, Soy Goku'
        const {container } = render (<FirstApp titulo={titulo}/>);
        screen.debug();
        //console.log(container);
        expect ( container ).toMatchSnapshot();
    })


va a probar que la url de la img sea la url que le pasamos
screen.getByRole('img').src).toBe (url)
otra manera es 
const { src, alt} 0screen.getByRole('img')

Tema 105 Pruebas sobre getGifs

Lo hace porque es otro componente simple.

Va a validar que que al llamar a los gifs nos devuelve algo
y lo que no devuelve tiene un id, title y url.

dado que getGifs tenemos que llamarla con await el test lo define con async quedando
así

    test('debe de retornar un arreglo de gifs', async() => { 
        
        const gifs = await getGifs('Oone Punch');
        expect(gifs.length).toBeGreaterThan(0);
        expect (gifs[0]).toEqual({
            id: expect.any(String),
            title: expect.any (String),
            url: expect.any (String),
        });

     });


Tema 106

Ahora mira de hacer pruebas en otro componente sencillo
el siguiente sería el addCategory
No quiere hacer las pruebas con snapshot.
El componente a hacer pruebas es el addCategory

este componente se encarga de capturar la categoria.

Le añade propTypes para que siempre tengamos una función de entrada.
Lanzara el evento ura fireEvent.input( input, target: {value:'Samanta})

Tema 107 Simular el submit del formulario

Para evaluar el submit evaluará
fireEvent.input(input, { target: {value:'Solo'}}); --> rellena el input con la palabra Solo
fireEvent.submit( form) --> lanza el submit
Despues de lanzar el submit sabemos que el input debe quedar a vacio.

Tema 108 jest Functions

Jest tiene funciones mock que te permiten preguntar sobre estas funcones, si se han llamado, si se han llamado con un parámetro,
si se han llamado 2 veces etc...

Esto lo usa para hacer validaciones sobre el componente addCategory ya que este recibe como parémtro una función que si 
miramos el código debe ser llamada siempre que el valor del text box no sea vacio.

Para probarlo hace:

const onNewCategory = jest.fn();
render(<AddCategory onNewCategory= {onNewCategory}/>)
const input = screen.getByRole

expect (onNewCategory).toHaveBeenCalled(); //Ha sido llamada 
expect (onNewCategory).toHaveBeenCalledTimes(1); //Ha sido llamada una vez
expect (onNewCategory).toHaveBeenCalledWith( inputValue); //Ha sido llamada con la variable inputValue

Ahora pide que validemos que si el inputValue es vacio no se llama

Tema 109 

Dice que el más fácil es el useState, pero lo deja para el final.
Decide hacer el GifGrid.
La primera prueba es que inicialmente debe mostrar loading
Añade proptypes a GifGrid, para tener la categoria 
Prueba el estado inicial es decir debe aparecer loading y la categoria

En el siguiente hará cómo se debe comportar cuando encuentra gifs.

Tema 110

Ahora simula que el useGetGifs retorne gifs. Importamos el useFetchGifs y
le dice a jest que función debe mockear 
jest.mock("../src/hooks/useFetchGifs")

Eso da error porque ahora necesita definir qué valores debe retornar esta función
useFetchGifs.mockReturn({
    images: [],
    isLoading: true
})

crear un objeto que tendría las imágenes
const gifs = [
    {
        id:'ABC',
        title:'Saitama',
        url:'https://localhost/saitama.jpg'
    },
    {
        id:'Default',
        title:'Goku',
        url:'https://localhost/goku.jpg'
    }
]

Tema 111 Probar customHooks

Antes de la versión 18 había que cargar una librería https://react-hooks-testing-library.com/ pero ahora ya viene incluida.
Hace primero una prueba para validar el estado inicial del hook.
Para poder ejecutar el hook en una prueba debe llamarlo desde renderHook de este modo:
renderHook retorna un objeto llamado result

const { resultado } = renderHook( () => useFetchGifs('Mi categoria'));

y sobre el resultado hace validaciones.

const { imagen, estaCargando} = resultado.current;

expect (imagen.letgh).toBe(0);
expect (estaCargando).toBeTruthy();

Esto no funciona porque el renderHook devuelve result no resultaod, y el useFetchGifs devuelve images y isLoading

Para probar el siguiente estado del hook introduce una nueva función que se llama waitFor que es asincrona
por lo que tenemos que poner el test con async y hacer un wait.
Esta función te permite indicar que espere ha que ocurra algo, en este caso que la longitud de imágenes se mayor que 0.

await waitFor(
    ()=> expect (result.current.images.length).toBeGreaterThan(0)
);

luego hacemos las otras consultas

cons { images, isLoading } = result.current;
expect (images.length).toBeGreaterThan(0)
expect (isLoading).toBeFalsy()

112 ahora pide que probamos GifExpertApp

Dice que probamos la funcionalidad que no hemos probado onAddCategory

113 Código fuente de la sección
https://github.com/Klerith/react-gif-expert/tree/fin-seccion-8

Tema 114 

¿Qué veremos en esta sección?

Profundizar en el tema de los Hooks

Crear otros customHooks

useState

useCounter - Personalizado

useEffect y sus precauciones

useRef

useFetch - Personalizado + optimizaciones

useLayoutEffect

Memo

useMemo

Crea un nuevo proyecto yarn create vite
hook-app
yarn
en src borra todo menos el main.jsx
crea un index.css con

body {
    padding: 20px;
}

button {

    margin-right: 10px;
}

crea una HooksApp como component con el comando 'rafc', 
añade bootstrap 
 
https://getbootstrap.com/ vamos a getstarter y copiamos el url del css
 <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">



este componente mostrará 3 números y un botón que incrementará uno de ellos.


Esto le sirve para enseñara que un useState puede tener un objeto y no sólo una variable.
A la hora de actualizarlo hay que actualizar todo el objeto. En este caso el objeto son tres números 
para actualizar uno lo que hace es pasar el objeto con el comando sprite ...status, counter+1, y el campo del status que queremos
acuatlizar.

Para actualizar el estado si hago esto:

<button onClick={setState(state+1)}>+1</button>

se crea un bucle infinito tengo que hacerlo así ¿?¿?¿? https://reactjs.org/docs/faq-functions.html#why-is-my-function-being-called-every-time-the-component-renders

<button onClick={() => setState(state+1)}>+1</button>

Tema 118 

Crea un customhook para implementar un contador
un hook es una función que tiene un return es decir

const useCounter = ()  => {
    return {

    }

}

Para ello crea una nueva carpeta y en ella un nuevo componente CounterWithCustomHook, 
este llamará a nuestro custom hook (useCounter), que tendrá internamente un useState

Para hacer que retornemos la función plantea varios métodos.

export const useCounter = (inicial = 10 ) => {

    const {counter,setCounter} = useState(inicial)

    const increment = ()  => {
        setCounter(counter +1)
    }
    return {
        counter,
        increment

    }
}

Tema 120

Ahora crea un nuevo componente que tiene un formulario.
Añade un useState para guardar el estado del formulario.

Curioso: Una vez que añadimos el estado al formulario react ya no nos deja manipularlo.
Enlaza esa parte del html a un estado y entonces aunque intentemos tocar el formulario coge el control
y no lo renderiza y no permite camibarlo

Los useEfects es para lanzar efectos secundarios.
se ejecuta cuando pasa algo, si no le pones dependencia se va a llamar cada vez que se repinte el componente.
Sale dos veces porque tenemos strictMode si lo quitamos sólo se ejecutará sólo una vez.

useEffect( () => {
    console.log('Me acabo de ejecutar');
})

Tema 121

Al useEffect le puedes pasar un parámetro que es una array donde le dices cuando se debe ejecutar.
si le pasas [] se ejecutará la primera vez que se renderice el componete, si no  le pasas nada se ejecuta cada vez que se renderiza el componente.

useEffect( () => {
    console.log('Me acabo de ejecutar');
},[])

Pero si queremos que se ejecute cuando cambie el formulario, react dice que es mejor crear otro useEffect uno para cada parte
por tanto creo uno nuevo 

useEffect( () => {
    console.log('Me acabo de ejecutar por que ha cambiado formstate');
},[formState])

Y si queremos que sólo sea en el email, pues creamos otro 

useEffect( () => {
    console.log('Me acabo de ejecutar por que ha cambiado formstate');
},[email])

Tema 122

El useEffect tiene tres partes:

    useEffect(() => {
      first
    
      return () => {
        second
      }
    }, [third])


    first: es el cuerpo,
    second: es el cleanup,
    third: arreglo de dependencias

    Para mostrar el uso de estas tres partes crea un Funcional component  que escribe un mensaje.
    Este funcional componente sólo hara que se llame si el username es uno determinado

    username  === 'pp' <Mensaje/>

    En el componete crea un use efect que en el first pone un console log indicando que se ha montado y en el return que se ha desmontado

    Tema 123

    Para mostrar el tema de montar y desmontar un useEffet en el useEffect anterior al montarse que lo hará al cargar la página, cogerá un listener
    que cogerá el movimiento del ratón, y veremos que si no hace nada en el desmontar return, seguimos enganchados al listener

    window.addEventListener('mousemove', (event) =>  {
        console.log(event);
    })

     para remover debemos tener la referencia a la función que queremos demonstar. Para hacerlo en lugar de tener una función anónima crear una función
     quedando así:

const onMouseMove = ( {x.y}) => {
    const coords = {x,y};
    console.log(coords);

}
      window.addEventListener('mousemove', (event) =>  {
        console.log(event);
    })

    Para que tenga más sentido muestra las coordenadas en la página. Dado que es algo que cambia de estado usa un useState para las coordenadas.
    Lo mostrará al lado del mensaje

Tema 124 Formulario con CustomHooks

Primero lo que hace es crear un functional component con el formulario.
Luego crea un customhook que tendrá el useState y la función de actualizar el formulario.
Este customhook lo hace genérico para que actualice cualquier formulario.
Para ello le pasa como parámetro un objeto que representa el formulario

Aplica un truco para no tener que desectructurar en otra linea es decir  en lugar de hacer esto

  const {formState,onInputChange} = useForm({
        username: 'pp',
        email:'popo',
        password:'miPassword',
      })

  const {username, email, password} = formState;

  hace esto 

    const {formState,onInputChange, username, email, password} = useForm({
        username: 'pp',
        email:'popo',
        password:'miPassword',
      })

  //const {username, email, password} = formState;

  porque en el useForm ha desetructurado retronando esto :

    return {
    ...formState,
    formState,
    onInputChange,
  }

  126 
  crea una nueva carpeta 03-examples dentro crea un nuevo funcional component que se llama MultipleCustomHooks

  vamos a usar una api de https://fakestoreapi.com/products/1 y va hacer que un customhook se encargue de obtener la imagen
  y lo combina con el customhook que hace de contador
  Crea un hook useHooks.js
  Le añade un useEffect para recuperar los datos y un useState para devolverlos.

  Tema 127

  Aque lo que hace es enriquecer el MultipleCustomHooks para que sepa leer cuando el useFetch no ha retornado datos
  quiere desestructurar los datos pero no lo puede hacer si es nulo.
  Para hacerlo se aprovecha de un curiosidad del javascript. El undefined

  !undefined es false,  y !!undefined es true,

  const {author, quote} = !!data && data[0];
 
  si intentas desestrucutra algo de false da un undefined
  const { a,b} = false;
  undefined

  !null es false, 

  si data es !!data true entonces desectructura data [0]

  Tema 128

  Nos hace hacer usar el counter que hicimos para que cuando clickemos al botón vayamos a buscar otra url.
  No lo hago perfecto porque no se concatenar elegantemente hago esto:

   const url = 'https://fakestoreapi.com/products/' + counter;
    const {data, isLoading, hasError} = useFetch(url);

    y debería haber hecho

 const url = + counter;
    const {data, isLoading, hasError} = useFetch(`https://fakestoreapi.com/products/${counter}` );

Tema 129

Hace optimaciones
Como tenemos 3 hooks en un directorio crea un archivo de barril que tiene
export * from './useCounter';
export * from './useFetch';
export * from './useForm';
lo llama index.js

y ahora podemos substituir:

import { useFetch } from '../hooks/useFetch'
import { useCounter } from '../hooks/useCounter';

por

import {useFetch, useCounter} from '../hooks/';

Pide que hagamos dos componentes para que el código no se vea tan feo que tengan la funcionalidad
      isLoading
        ? (
            <div className=" alert alert-info text-center">
              Loading...
            </div>
        )
        : (
          <blockquote className="blockquoute text-end">
            <p className="mb-1">{title}</p> 
            <footer className="blockquote-footer"> {category} </footer>
          </blockquote>
          

        )

quiere que los llamaremos

<LoadingQuote/>
<Quote/>

No he sabido hacer como pasar los parámetros que se hace así;

<Quote title={title} category={category}/>

y se regogen ({title,category})

Tema 130 useRef

Sirve para manejar un valor como el useState pero no lanza la renderización.

Como ejemplo crea un componente que tienen un input y un botón.
Cada vez que clica el boton el input debe seleccionarse.
Para ello crea una referencia al input con el useRef y cuando hace click
la lee y lo activa.

Al final es ponerle una marca para poder referenciarlo fácil....


<input
        ref={inputRef}   
        type="text"
        placeholder='Ingrese su nombre2'
        className='form-control'/>

    <button className='btn btn-primary mt-2'
        onClick={onClick}>Set Focus </button>



    const inputRef = useRef();

    const onClick =() => {

        inputRef.current.select();
    }

Tema 131 useLayoutEffect

Es como el useEffect, pero se ejecuta cuando se ha renderizado todo. El lo usa normalmente para saber el tamaño definitivo de un contenedor

https://es.legacy.reactjs.org/docs/hooks-reference.html#uselayouteffect

Crea un directorio 05-useLayoutEffect . Crea un objeto que se llama Layout.jsx y lo llena con lo que tiene le MultipleCustomHooks

le añade el style flex al componente quote, en lugar de hacerlo con un string lo hace con un objeto porque así lo puede modificar con react
style={{ display: 'flex'}} en lugar de style="display: 'flex'"

En el Quote ha puesto lo del estilos
Además importa el useLayoutEffect y usa el useRef apuntandolo al párrafo
console.log(pRef.current.getBoundingClientReact())

Para mostrar el ancho en pantalla como siempre crea un useEffect

<code>{ JSON.stringify(boxSize) }</code>

Tema 132 react.memo

crea un componente que usa el componente contador. En ese componente añade otro componente para mostrar el valor del contador.
Al componente que muestra el valor del contador le pone un console.log para ver cuando se ejecuta.
En el primer componente crea un botón que actualiza otro valor. Comprueba que react por alguna razón cuando clica este botón renderiza
todo el componente incluso el componente que muestra el valor del contador, cuando en principio no lo debería hacer porque no ha cambiado su valor.
Para evitar esto, usa un componente de react que se llama memo. Este lo usa en el componente que muestra el valor del contador. 
Con este cambio el componente que muestra el valor del contador ya no se renderiza cuando no toca.

 Si en tu componente utilizas props que constantemente están cambiando, no utilices react.memo(), ya que de igual manera tendrá que realizar el renderizado ya que los props cambiaron.

Si tu componente solo en ocasiones cambia o modifica los props puedes usar el react.memo() y su rendimiento sera muy bueno.

Padre: Memorize 
Hijo : Smalli


Tema 133

Ahora muestra el uso del hook useMemo, este hook recibe una función cuyo valor debemos guardar y un parámetro que indica que si este cambia se debe volver a ejecutar.
Copia el componente memorize y quita la parte de small, se añade una función pesada que será la memorizada  y la asocaia al counter.

Padre: MemoHook 
Hijo : No hay, aqui lo que memoriza es algo que es muy pesado para que no se ejecute cuando se renderiza el componente.

Tema 134 useCallBack

Crea un componente con un contador, y otro componente que tiene el botón con el que incrementamos el contador.
usará el useCallBack para que sólo se renderice lo que toca.

Cada vez que pulsamos el botón el componente que tiene el botón se vuelve a generar/dibujar

Intenta memorizar todo el componente con memo pero no funciona. Esto es porque la función  que está memorizando, la función del padre, se guarda una referencia
y claro cuando el componente padre se redibuja/genera porque el valor ha cambiado también cambia la dirección donde está la memoria.

useCallback memoriza funciones, memoriza la función en el padre, y el hijo que tiene el memo, ahora sabe que la función no ha cambiado y por tanto no se renderiza.
El useCallback guarda la función tal como esté, es decir con el valor de las variables donde se tomo la foto.
Si le pone el counter para que se guarde cada vez que se guarde, pero claro como cambia el valor la función cambia....
Para evitarlo en lugar de hacer:

const incrementarFather = useCallBack(
    () => {
        setCounter(counter +1 )
    }
)

hace 

const incrementar Father = useCallBack(
    () => {
        setCounter( (value) => value +1)
    }
)

Ahora la función queda guardada, pero el setCounter internamente nos hace cambiar el value y encontes ahora si que se incrementa de forma dinámica, es decir,
hemos guardado la función, la función no cambia, en el otro caso counter cambiaba ahora no hacemos referencia a nada que cambie por lo que la función se mantiene siempre
intacta.

Padre: CallBackHook
hijo: ShowIncrement 

Tema 136
 
07 tarea demo
Es un padre que expone una función que pasa al hijo para que la llame.
El padre tiene un estado que va cambiando con la función con lo cual cuando el hijo ejecuta la función del padre, el estado
del padre cambia y como se reescribe el padre incluida la función entonces el hijo también se reescribe.

En teoria tenemos que hacer lo mismo que antes en el padre guardar una copia de la función que no cambie con el useCallBack
en el hijo en principio creo que no.

He tenido que poner el hijo en memo,porque sino también se renderizaba, no lo acabo de entender.


Hola, me está costando entender esta parte de memo así que diré lo que entendí para ver si es correcto.

memo: Guarda en memoria componente, su dependencia para renderizar nuevamente son los props que recibe

useMemo: Guarda en memoria el valor del retorno del callback. Renderiza el componente cuando el valor de la dependencia cambia.

useCallback: Guarda en memoria el callback. Renderiza el componente cuando el valor de la dependencia cambia.

Al haber cambios en el state, React realiza los cambios necesarios excepto con los componentes hijos que son renderizados por completo.

1. Como el valor de los botones no va a cambiar, queremos que los botones no se rendericen cada vez que haya un cambio en el state, así que los almacenamos en memoria con React.memo. Pero los botones si se van a renderizar nuevamente si hay cambios en sus props.

2. Al renderizar nuevamente con estos cambios, se sigue creando una nueva instancia del callback, por lo que al ser una nueva referencia, React lo detecta como una prop diferente, esto hace que el componente hijo se siga renderizando

3. Para solventar esto guardamos en memoria la referencia del callback, de esta forma el prop que recibe el componente hijo va a ser el mismo cada vez que se ejecute el ciclo de cambios de React  

Sección 10. Tema 140 useReducer es como es useState, se usa cuando hay muchas cosas que cambian.
Un reducer es una función normal que no puede ser asincrona. Debe ser pura, no llamar a otras. Siempre debe retornar un nuevo valor. Recibe estado inicial y la acción.
No puede llamar al localStorage o sessionStorage.
Si programamos bien, en el reducer deberían estar todas las funciones que hace nuestra aplicación, así si no conocemos el código solo con buscar el reducer sabriamos que hace.

Supongamos que hacemos el mantenimiento de usa lista.

La lista tiene el estado inicial que se lo pasamos a la vista.
La vista puede añadir un elemento, para ello llama el reducer con la acción de añadir.
Este lo añade y la vista lo renderiza.

Sección 10 . Tema 141

Crea la caperta 08 donde crea un archivo js que ejecuta holamundo
y lo añade al main quitando la parte visual.

 Sección 10. Tema 142

 Dentro de la carpeta que ha creado antes crea un archivo intro-reducer.js

 Un reducer es una función simple que recibe un estado inicial y una acción.
 Le dice cómo debe cambiar el estado.
 Y siempre retornar un estado.
 Se usa cuando el estado es complejo un objeto que queremos camiar el estado.

 Explica que el estado se debe cambiar con la función y no funciones push que lo que 
 hacen es mutar el objeto. React con un push no lo renderiza.
 Ahora crea otro item de la lista y se lo pasa indicandole en el action que
debe añadirlo y él que debe añadir:

const addTodoAction = {
    type: '[TODO] add todo',
    payload: newTodo
}

Si cuando llamamos a reducer no hay cambio de estado entonces
react se da cuenta y no hace nada.

Sección 10 Tema 143 useReducer
Ahora explica la documentación de useReducer, es parecido al useState
pero se usa para estados complejos.

https://es.legacy.reactjs.org/docs/hooks-reference.html#usereducer

Empieza a crearse un nuevo componente TodoApp.jsx con una lista de cosas a hacer.
y hay crea un el hook useReducer que tiene como parámetro una función reducer
que hemos creado antes, que recibe un estado y una acción con payload.

En otro archivo define esta funión, la función reducer (todoReducer.js)

Sección 10 Tema 144 

Ahora maqueta el componente para que se vea bonito

Sección 10 TEma 145

Hacer 3 componentes como tarea.

el ul será un componente será TodoList

el li será un todoItem
el form sera el TodoAdd que retorne un objeto

He mirado el ejercicio del gifExpert donde se hacia lo mismo, no sabia pasar variables, ni funciones...

Sección 10 Tema 146 Resolución de la tarea.

Él utiliza el hook que hicimos de formulario en lugar de crear un useState y una función onChange

Sección 10 Tema 147

Usará el reducer para añadir un todo a la lista.
Toca la función reducer  añadiendo la acción
'[TODO] Add Todo': return [ ...initialState, action.payload]

Sección 10 Tema 148 hacer persistente la lista de todo en el navegador

En el navegador Aplication. localStorage está en el ordenador, las cookies son más pequeña y viajan al servidor.
La idea es que cuando la lista de todo cambien se guarden, para eso usa el useEffect
localStorage.setItem('todos',todos) no funciona porque sólo deja guardar strings
localStorage.setItem('todos',JSON.stringfytodos)

Pero si recargamos..., se pierden, esto es porque el effecto se carga con el valor vacio porque ha cambiado. 
Y la lista ha cambiado porque al refrescar se ejecuta el useReducer que inicializamos con la lista vacia.
Para evitarlo usa el useReducer,usando la función init, que la define para que lea lo que hay en el localStorage
const init = () => {
    return JSON.parse(localStorage.getItem('todos')) || [];
}
init o inicializar:
https://kentcdodds.com/blog/use-state-lazy-initialization-and-function-updates


Sección 10 Tema 148 Borrar un elemento de la lista

Al hacer que el botón borre le tenemos que pasar la función de borrado desde arriba al TodoList y luego al TodoItem, no es muy elegante pero 
es la única forma de hacerlo hasta ahora, con useContext no hará falta.

Sección 10 Tema 149 Marcar como hecho un elemento.

Ahora lo que hace es marcar con el useReducer el atribuo a done, y en el item lee este valor renderizando diferente, lo hará 
de varias formas una es esta:

className={`align-self-center ${todo.done && 'text-decoration-line-through'}`}

Esto la malo que tiene que si es false dejará escrito la palabra false, para que no lo haga hace

className={`align-self-center ${ (todo.done) ? 'text-decoration-line-through':''}`}

codigo del reducer curioso con el map
            initialState.map( todo => {
                if ( todo.id === action.payload ) {
                    return  {
                        ...todo,
                        done:!todo.done
                    }
                }
                return todo;
            });

Sección 10 Tema 149 ejercicio

Dice que hagamos un custom hook (useTodo) para limpiar el javascript 

const {todos, handles....} = useTodos()

Para modificar el done, lo hace igual que en el ejercicio anterior pasando una función hasta el item

Sección10 Tema 152 Tarea contadores

Ahora pide que añadamos la funcionalidad a los contadores dentro del usetodo y nos muestra como deben ser:

el total de elementos es todos.length 
y el total de tareas completadas: todos.filter(todo => !todo.done).length

Sección 11 Tema 154 introdución al useContext
El useContext sirve para pasar cosas entre componentes además te avisa cuando algo cambia para que lo leas.
Usará el router para mostrarnos un caso en el que sólo se puede hacer con un useContext, no pasando parámetros de padres a hijos como hemos hecho antes.
Sección 11 Tema 155 introdución al useContext
¿Qué veremos en esta sección?

Context

Provider

useContext

React Router

Links y NavLinks

CreateContext

SPA ( Single Page Application )

El objetivo de la sección es principalmente aprender sobre el Context, el Router es un valor agregado que explotaremos mucho más en próximas secciones, pero al usar un Router, podemos explicar claramente el problema y necesidad del context.


Sección 11 Tema 157 añadir rutas
Creo otro directorio 09-useContext y crea dos  funcional components
mainApp.jsx que será una página
aboutPage.jsx
homePage.jsx
LoginPage.jsx

instala react router v6 https://reactrouter.com/en/main
usamos el   BrowserRouter es un componente higher component porque es un componente que contiene otro componente.

para instalarlo:  yarn add react-router-dom (https://www.freecodecamp.org/news/how-to-use-react-router-version-6/#:~:text=To%20install%20React%20Router%2C%20all,%2Drouter%2Ddom%406%20.)

Sección 11 Tema 158 Configurar Router en React
Explica como configurar el router en react dice que miremos la documentación
https://reactrouter.com/en/main

Cómo la página MainApp quiere que salga siempre y esta tenga las otras incrustadas, confiura el router en ella
<Routes>
Define la ruta de la /
<Route path="/" element={<HomePage/>}/>
<Route path="login" element={<LoginPage/>}/>
<Route path="about" element={<AboutPage/>}/>
si en el navegador ponemos una ruta que no está definida entonces sólo mostrará lo que tenga el MainApp. Para que muestre una en este caso se define lo siguiente
<Rotue path="/*" element={<LoginPage/>}/> pero claro esto lo que hace es dejarte en el navegador la url que pusiste... es mejor hacer que navege a la página para ello hace
<Rotue path="/*" element={<Navigate to="/about>} /> es decir que navege un path definido en otro router
</Routes>

El Route tambien es un higher component que contiene otros componentes como son las páginas. En el navegador podemos ver como anida los componentes en la opción component

Sección 11 Tema 159 Links
Ahora hace unos enlaces para navegar a las diferentes páginas, para ello primero usa el tag a de html pero aunque funciona esto lo que hace es renderizar toda la página.
Cuando sólo debe renderizar la parte de abajo. 
Para solucionarlo lo cambia por el componente Link que hace lo mismo pero sin recargar toda la página.
También cambia el estilo del tag a para que el Link se vea mejor, esto lo puede hacer porque el Link en el fondo se renderiza como un a.
Luego solicita que esta parte del código la encapsulemos en un componente que se llame Navbar.jsx, es el que gestionará el menú de navegación.

Sección 11 Tema 160 NavLink

NavLink es un componente que permite saber qué link se ha pinchado con lo que nos permite cambiar el color. En este ejercicio cambia la barra de links anterior
por estos links a partir de un menu de bootstrap,y la funcionalidad nueva del componente.

1.- Vamos a getbootstrap.com en docs y buscamos navbar
2.- copia el ejemplo que pone navbar home feature Pricing  Disabled
es decir este 

<nav class="navbar navbar-expand-lg bg-body-tertiary">
  <div class="container-fluid">
    <a class="navbar-brand" href="#">Navbar</a>
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarNav">
      <ul class="navbar-nav">
        <li class="nav-item">
          <a class="nav-link active" aria-current="page" href="#">Home</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="#">Features</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="#">Pricing</a>
        </li>
        <li class="nav-item">
          <a class="nav-link disabled" aria-disabled="true">Disabled</a>
        </li>
      </ul>
    </div>
  </div>
</nav>

3.- Copia esto en el componente que hemos creado Navbar, y le hace los siguientes arreglos
3.1.- cambiar class por className
3.2.- cambia light por dark
con ctrl+d selecciona las palabras iguales 
cambiar:
 <a class="navbar-brand" href="#">Navbar</a>
por
 <Link class="navbar-brand" href="/">useContext</Link>

 <a class="nav-link active" aria-current="page" href="#">Home</a>
 <NavLink es otro higher component
 <NavLink to="/" ClassName= {'nav-link' }>Home</NavLink>

 substituyy el li y el A

 className=(args)=>{
    console(args)
    return 'nav-link'
 }

NavLink nos dice con isActive si la url del navegador es la url del path del NavLink
entonces hace 
className={({ isActive}) => `nav-link ${ isActive ? 'active' : ''}` }
3.3.- añande la clase rounded-3

Sección 11 Tema 161 CreatContext y ContextProvider

El contexto es la estructura de componentes de nuestra aplicación
Si quisieramos compartir info entre páginas 
Podemos tener varios contextos en la aplicación.
Crea un directorio llamado context
Crea un UserContext.jsx y excribe:

export const UserContext = createContext();
crea otro archivo como functional component para crear el provider.

UserProvider.jsx que contiene un funcional component
En los parámetrosde entrada pone uno que sea children
que da así:

export const UserProvider= ( { children }) => {
    return (
        <UserContext.Provider value={{ hola: 'Mundo' }}>
        {children}
        </UserContext.Provider>
    )
}

con esto el cualquiera que use el provider va a tener acceso al objeto que
ha creado en el value con una propiedad hola valor mundo

Este provider lo tenemos que poner en la parte más alta del árbol de
componentes para que los hijos lo puedan consultar.

Lo pone en el Navar. Ahora el UserProvider está en el árbol de componentes.

Por tanto, creas un contexto, luego como componente creas un provider que usa el contexto y le añade objetos., 
y luego pones el provider en la aplciación en la parte más alta del árbol de componentes.

Sección 11 Tema useContext.

Sirve para coger cosas del contexto.  Es un hook


const algo = useContext(UserContext);
Coge el objeto usario y lo muestra en la página de login, luego lo borra y lo que hace es
crear un botón en la página de login que mete un objeto usuario y lo muestra en todas las páginas.

en el home pone esto para cuando llege a null el usuario no permite
 <h1>HomePage<small>{user?.name}</small></h1>


Sección 12 Tema 166
Como estamos usando vite tenemos que instalar jest que si usaramos react ya vendría instalado.

vamos a : https://gist.github.com/Klerith/ca7e57fae3c9ab92ad08baadc6c26177

y ejecutamos 

yarn add --dev jest babel-jest @babel/preset-env @babel/preset-react 
yarn add --dev @testing-library/react @types/jest jest-environment-jsdom

yarn add --dev whatwg-fetch

Añadimos al package.json en scripts 

"scripts: {
  ...
  "test": "jest --watchAll"

Crear el archivo babel.config.js con este contenido
module.exports = {
    presets: [
        [ '@babel/preset-env', { targets: { esmodules: true } } ],
        [ '@babel/preset-react', { runtime: 'automatic' } ],
    ],
};

Crear el archivo jest.config
module.exports = {
    testEnvironment: 'jest-environment-jsdom',
    setupFiles: ['./jest.setup.js']
}
Crear el archivo jest.setup.js 
// En caso de necesitar la implementación del FetchAPI
import 'whatwg-fetch'; // <-- yarn add whatwg-fetch

ejecutamos yarn test 

Sección 12 Tema 165 pruebas sobre el useCounter

Intenta probar los hooks que tienen menos dependencias, es decir menos parámetros.

Crea la estructura en la nueva carpeta test para hacer pruebas sober el useCounter
La primera prueba que hace es comprobar que si no le pasamos nada los valores que devuelve son los por defecto.

Al hacerlo:

  test('Debe retornar los valores por defecto', () => { 

    const {result } = renderHook(()=> useCounter());
    const { counter, decrement, increment, reset} = result.current;

    expect( counter ).toBe(10);
    expect( decrement).toEqual ( expect.any(Function));
    expect( increment ).toEqual( expect.any(Function));
    expectç( reset ).toEqual( expect.any( Function));
    
  });  

Me da error el jest:

    Details:

    I:\udemy\repogit\cursoReact\udemy-react-de-cero-a-experto-hooks-y-mern\05-hook-app-vite\test\hooks\useCounter.test.js:1
    ({"Object.<anonymous>":function(module,exports,require,__dirname,__filename,jest){import { renderHook } from '@testing-library/react';
                                                                                      ^^^^^^

    SyntaxError: Cannot use import statement outside a module



Luego pide de ejercicio, que si le pasamos el valor 100 que comprobemos qué valores devuelve.


    "@babel/preset-env": "^7.23.8",
    "@babel/preset-react": "^7.23.3",
    "@testing-library/react": "^14.1.2",
    "@types/jest": "^29.5.11",

Sección 12 Tema 168
    Sigue haciendo pruebas con el hook counter que creamos
    Intenta hacer uno para validar que el incrementar funciona.
    Cuando lo hace se encuentra dos problemas a patir del código siguiente:

const {result } = renderHook(()=> useCounter(100));
const { counter, decrement, increment, reset} = result.current;
increment();
expect(counter).toBe(101)

El primer error es que se queja que no podemos ejecutar increment porque actualiza
un estado de react. El counter dentro tiene un estado y no se permite hacerlo
directamente en el test se debe encapsular en un act, quedando así:

act( () => increment())

El segundo problema es que el valor no se actualiza, esto es porque al ejecutar
const { counter, decrement, increment, reset} = result.current;

en counter nos hemos quedado una copia por que es un tipo primitivo.

Para recuperar el valor correcto, debemos hacer
expect( result.current.counter).toBe(101)
en lugar de 
expect( counter).toBe(101)

También explica que si hacemos:
incrementar();
incrementar(2);

El valor esperado sería 103 pero no lo es. Esto es porque en el
counter la función incrementar está definida como:

setCounter(counter + value)

donde counter es la definición del state:
const [counter,setCounter] = useState(inicial);

para que esto no ocurra debemos dejar la función counter así:

setCounter( (current) => current + value)

luego hace el decrementar

Sección 12. Temas 169
Ahora prueba el useForm
La primera prueba hace que debe devolver los valores por defecto.
Para ello crear un useForm con un objeto con los valores por defecto
y luego hace el expect 

expect(result.current).toEqual({
    name:initialForm.name,
    email: initialForm.email,
    formState: initialForm,
    onInputChange: expect.any (Function),
    onResetForm: expect.any (Function),
})

Luego dice que hagamos una prueba que

debe de cambiar el nombre del formulario

montar el hook
oninputChange //act event

//Excep result.curren.name == juan
//expec result.current.formState.name
Como el inputchange espera un evento le crea un evento tal cual lo espera
{ target: { name: 'name' ,value:newValue}}

Luego hace una pruebat del reset

Sección 12. Tema 170

Ahora prueba el MultipleCustomHooks

Intenta renderizar el componente para hacer la prueba por defecto
render (<MultipleCustomHooks />)
screen.debug


Al hacerlo me da el error Jest worker encountered 4 child process exceptions, exceeding retry limit

para corregirlo descomento las lineas que tenía comoentadas

module.exports = {
    testEnvironment: 'jest-environment-jsdom',
    setupFiles: ['./jest.setup.js']
}

en el acrhivo jest.config.cjs

y el estado inicial es que este como hace el debug.
Podría hacerlo con snapshot, pero lo hace con expect buscando cosas
que tenga el screen.

excpect( screen.getByText('Loading...'));

const nextButton = screen.getByRole('button',{name:'Next quote'})
expect(nextButton.disabled).toBETruthly();


Sección 12. Tema 171

Ahora hace un test que debe mostrar un quote, una llamada...
Lo hace generando un mock para probar el useFetch

con jest.mock( useFecth) genera un mock

import { useFetch } from '../../../src/hooks/useFetch';

jest.mock('../../../src/hooks/useFetch');
Esto da error, pare evitarlo, en cada llamada al hook hay que definir resultados a cada mock.
console.error
      Error: Uncaught [TypeError: Cannot destructure property 'data' of '(0 , _useFetch.useFetch)(...)' as it is undefined.]

Para ello hace en cada test:

useFecth.mockReturnValue();  como queremos que devuelve un objeto con tres campos:
data:null,
isLoading:null,
hasError:null

Esto es porque el MultipleCustomHooks tiene dentro un useFecth que retorna un objeto:

    const {data, isLoading, hasError} = useFetch(`https://fakestoreapi.com/products/${counter}` );

Ahora pide que evaluemos la función incrementar.

para ello selecciona el boton y le lanza un fireEvent.click(boton);
y luego como ejercicio pide cómo debe ser el expect
expect( xxxx ).toHaveBeenCalled();

La solución pasa por lo mismo, por moquear el useCounter y la función increment

        const mockIncrement = jest.fn();
    useCounter.mockReturnValue({
        counter:1,
        increment: mockIncrement
    });

Luego hace que se borren las pruebas cada vez que se ejecuten, así la función siempre se abrá ejecutado 0 veces.
    beforeEach(()=>{
        jest.clearAllMocks();
    })    


Tema 172 Sección 12

Reducer es fácil de probar porque se le pasa un estado y una acción, y devuelve otro estado. Por tanto va a probar nuestro useReducer.
es js poque no retorna un functional component

test('debe regresar el estado inicial', () => { 
    
    const newState = todoReducer(initialState,{});

    //hace un toBe, porque como le pasa un objeto este viaja por referencia, con lo cual es exacto, el mismo trozo de memoria, no es una copia.
    expect(newState).toBe(initialState);
    
})


Luego crea una prueba para agregar un todo.

   const action = {
        type:  '[TODO] Add Todo',
        payload: {
            id:2,
            description: 'Nuevo todo #2',
            done: false
        }};

        const newState = todoReducer(initialState, action);
        expect( newState.length).toBe(2);
        expect( newState).toContain(action.payload);

Luego pone de tarea eliminar un todo y otro para que cambie el valor de un elemento (toggle)

174 Sección 12
Comienza aprobar el componente totoItem, prueba que se renderice correctamente
hace el test debe de mostrar el Todo Pendiente de completar
175 Sección 12
Hace otra prueba sobre el todoItem
La prueba es debe mostrar el todo completado
El span debe llamar al toogle cuando se hace click

Todas las pruebas se hacen sobre elementos del componente, es decir, no comprobamos si lo borra, sino que sólo cambia la apariencia.

Como ejercicio indica que haga "El botón debe de llamar al deleteTodo"

176 Sección 12

Ahora hace las pruebas del componente todoApp. Dado que renderiza en función de lo que le pasa en useTodos.
Por ello crea un useTodos y luego evalua en función del useTodos que le ha pasado.

177 Sección 12

Va a probar que el useContext funciona como esperamos. En nuestro caso evalua el contexto renderiza el usuario.
HomePage.test.jsx

Intenta primero renderizar el HomePage, pero les da error por que no tiene contexto.
Para evitarlo le crea un contexto:

render(
    <UserContext.Provider value={{user:null}}>
        <HomePage />
    </UserContext.Provider>
);

178 Sección 12

Ahora prueba el LoginPage debemos validar que cuando se hace click se ejecuta la función.

Hace dos pruebas: debe mostrar el componente sin usuario, debe llamar al setuser cuando se hace click en el botón.

179 Sección 12

Prueba el route,
si estamos en el / debe aparecer el Homepage..
si estamos en el.... debe apraecer el ...
sobre MainApp

Debe de mostra el home page es la primera prueba.
cuando lo hace directamente falla, porque es llamado con el BrowserRouter, pero no podemos usarlo porque estamos en consola.
Para hacerlo usa el MemoryRouter

Para navegar a un sitio en el MemoryRouter le pone el atributo initialEntries={['/Login']}

181 Sección 13

Va a crear un repositorio en git con las utilidades que hemos creado, con los customHooks.
¿Qué veremos en esta sección?

Subir código a nuestro repositorio

Tener un listado de customHooks y código que podemos reutilizar

Una idea para mantener tu repositorio ordenado con ejemplos

No es una sección obligatoria, pero puede ayudarles a tener su código ordenado y fácil de utilizar en proyectos futuros.

crea carpeta 06- mis-cunstoms hooks y copia todos los custom hooks
git init
git add .
git commit -m "Primer commit"
en github crea un nuevo repositorio llamdo custom-hooks

    
git remote add origin https://github.com/rakkso/custom-hooks.git
git branch -M main
git push -u origin main

Detecta que useTodos usa el useReducer de la carpeta 8 con lo que lo debe arreglar

184 Sección 13

Ahora crear va ha ordenar este repositorio.
Crea una carpeta para cada customhook
Trae el useTodo en otra carpeta
Trae el todoReducer y toca los path

188 Sección 14

¿Qué veremos en esta sección?

SPA ( Single Page Application ) a profundidad

Diferentes temas en la misma aplicación aplicados a diferentes rutas

Multiples Routers

Push y Replace en el History

Leer argumentos por URL

QueryParams

Aplicar filtros utilizando QueryStrings

En esta sección aún no haremos protección de rutas, pero dejaremos el estilo de esos componentes listos para la siguiente sección.

==> nos enseñará Router

189 Sección 13
Creación del cascaron de la aplicaicón

desde el directorio I:\udemy\repogit\cursoReact\udemy-react-de-cero-a-experto-hooks-y-mern
hace:
yarn create vite
heroes-spa
react
JavaScript

cambia el nombre la carpeta a 07-heroes-spa
entra dentro y ejecuta
yarn install

yarn dev para arrancar y vemos que tenemos una la aplicación arrancada

Borra de la estructura
app.css
app.jsx
logo
favicon
index.css lo cambia a styles.css

Crea un componente en src que se llama HeroesApp.jsx
hace rafc y pone el <h1>HeroesApp</h1>
Añade bootstrap, accede a getBootstrap.com y copia el link de css

 <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

crea dentro de src una carpeta assets y allí pone las imágenes

comenta que como va a ser una aplicación mediana con dos módulos crea dos carpetas
una para cada modulo, uno el del login auth, y otro el de los heroes (heroes)

y dentro, crea carpetas, pages, components, helpers, hooks., y en la de auth hace lo mismo

191 Sección 13
Tiene varios router uno para naveciones privadas y públicas.

Va a usar react router 6, la 5 era muy diferente.
yarn add react-router-dom@6

en la documentación lo hace con npm, pero debe ser lo mismo yarn add react-router-dom
luego en main.jsx importa BrowserRouter de react-router-dom
y lo pone en la main.jsx

Ahora configura las rutas, crea un directorio llamado router dentro del src.
AppRouter.jsx es el router principal como un componente con el siguiente contenido
<Routes>
<Route path="marvel" element={<Home/></Routes>} />
<Route path="dc" element={<About/>}
<Route path="login" element={<About/>}

En heroes dentro de pages, crea las páginas DcPages.jsx, MarvelPages.jsx y en auth pages loginPagex
Los crea con h1
el home será MarvelPage

En heroresApp pone el AppRouter
añade /* <Navigate to=="/marvel"

Luego debe usar el AppRouter dentro de la HeroresApp

192 Sección 13

Con las rutas, ahora define los menus con navbar (nos lo pasa de un recurso para no 
volver a hacer lo mismo). Dice que no hay una manera donde ponerlo.
Al final decide crear una carpeta ui, subcarpeta components.
Ahi crea un archivo de barril, index.js en components y otro fuera 

El de fuera 
//este exporta todo lo que esté en el arvhivo index de la carpeta components
export * from './components'

El de dentro
export * from './Navbar';

Así a la hora de importar no hay que especificar carpeta componente o archivo Navbar
import {NavBar} from '../ui'
a mi no me funciona tengo que poner ui/components

Luego el Navbar lo importa en el AppRouter y lo coloca encima de Routes

La tarea que pide es que cuando clicemos en la ruta quede activa con una clase. Para ello
dice que miremos como lo hicimos


Cambio 
className="nav-item nav-link" 
por 
className={({ isActive}) => `nav-link ${ isActive ? 'active' : ''}` }

en lugar de un navlink en la parte de login cambia a otra cosa. Es decir
de esto 

<NavLink 
                        className={({ isActive}) => `nav-item nav-link ${ isActive ? 'active' : ''}` }
                        to="/login"
                    >
                        Logout


Pasa a 

<span className="nav-item nav-link text-primary">
Óscar</span>
                   <button
                   className="nav-item nav-link btn"
                   >Logout</button>

193 Sección 13
Dice que no tiene mucho sentido que si estamos en login  enseñemos Marvel y DC
Es decir, si estamos en login no debe aparecer nada más.

Para hacerlo dentro de heroes crea carpeta routes dentro hace un component HeroesRoutes
Aquí dentro va a tener el navbar y los Routes originales, pero el de login lo quita.
y en el original quita todo menos lo de login
y añade /* hacia al Routes.

RouterApp queda:

    <>

    <Routes>

        <Route path="login" element={<LoginPage/>}/>
        <Route path="/*" element={<HeroesRoutes/>}/>
        
    </Routes>
    </>

Lo teniamos así:

import React from 'react'
import { Navigate, Route, Routes } from 'react-router-dom'
//import { MarvelPage } from '../heroes/pages/MarvelPage'
//import { DcPage} from '../heroes/pages/DcPage'
import {MarvelPage, DcPage} from '../heroes/'
//import { LoginPage} from '../auth/pages/LoginPage'
import { LoginPage} from '../auth'
import { Navbar } from '../ui'


export const AppRouter = () => {
  return (
    <>
    <Navbar/>
    <Routes>
        <Route path="marvel" element={<MarvelPage/>}/>
        <Route path="dc" element={<DcPage/>}/>
        <Route path="login" element={<LoginPage/>}/>
        <Route path="/" element={<Navigate to="/marvel" />}/>
        
    </Routes>
    </>
  )
}




añade div className="container">

Pide que añadamos dos rutas a search (este tiene que salir al navbar) y hero (no tiene que estar en el navbar)

194 Sección 13
Ahora quiere que cuando ciclemos logout vayamos a login y cuando hagamos login vayamos a la aplicación.
Primero en la de logout usa un custom hook de Router que lo que permite es navegar, se llama useNavigate. Además borra del historial la página de donde venimos, porque claro si hemos hecho logout y hacemos
para atrás no deberíamos estar dentro de la aplicación.

195 Sección 13
Comienza diciendo que la página de Dc y Marvel va a ser muy parecida con lo cual, crea un componente.
Primero crea un fichero que nos da, con la lista de superherores,lo ponemos en el directorio data.
Luego en helpers crea una función que filtrará por editor de los superherores, Marvel DC Comics.
Ahora pide que creemos un componente que muestre esta información, según sea la página.

196 Sección 13

Ahora crea un componente HeroCard que renderiza cada linea de los heroes en la lista.
Primero cambia HeroList estructurandolo mejor con html y luego llamando al nuevo componente que mostrará la información del Hero, con el nuevo
componente HeroCard.

197 Sección 13

Ahora quiere acabar la targeta, quiere que no repita los nombres entre alter_ego y characters si son iguales lo hace de dos formas 

1.- {
    (alter_ego!== characters) && (<p>characters</p>)
}

2.- Crea una varible con el contenido de <p>characters</p>
const characterByHero=(<p>{characters}</p>)
y luego usarlo
{
    (alter_ego!== characters) && characterByHero;
}
3.- O creando un componente dentro de este
const CharacterByHero = ({alger_ego,characters}) => {
    if (alter_ego === characters) return (<></>)

    return <p>characters</p>
}

y lo usa
<CharacterByHero characters={characters} alter_ego={alter_ego}/>

198 Sección 13

Ahora cuando le de al enlace deberá presentar la página de cada hero para ello en la ruta de hero que tenemos:

<Route path="hero" element={<HeroPage/>}/>

le añade que el path puede tener parámetros:

<Route path="hero/:heroId" element={<HeroPage/>}/>

para obtener los parámetros de la url (sólo rutas, no query params), usa el customhook de router useParams
const {heroid} =useParams(); que lo usa en la página de heroes

En el helpers crea una utilidad getHerobyId
export const getHeroById= (id ) => {
    return heroes.find(hero=> hero.id === id)
}

199 Sección 13
Ahora trabaja con la pantalla del hero.
Crea un botón para volver a atrás como ejercicio. No supe hacerlo se hacia con el useNavigate

const navigate = useNavigate();

navigate(-1)

200 Sección 13
Hace una optimización, sobre las funciones que llama en el componente HeroPage, para memorizarlas y que no se ejecuten cada vez que se renderice el componente.
En este caso no es necesario porque nose va a renderizar más de una vez, porque todo es estático.
useMemo para memorizar datos useCallback para memorizar funciones

const hero = useMemo( () => getHeroById(heroId),[heroId])

useMemo ejecutará getHeroById sólo cuando el heroId cambie.
Hace lo mismo para la lista de de heroes HeroList

201 sección 13

Añade estilos css que hacen que las cosas aparezcan, como en un ppt. Para ello va a la página https://animate.style/ y allí explica como
importarlo, ya sea por npm o por url.
El opta por meter 
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"
  />

En el heroCard pone
    <div className='col animate__animated animate__fadeIn'>

En el HeroPage tambien pone 
'img-thumbnail animate__animated animate__fadeInLeft'/>

202 Sección 13
Empieza con la página de search. Hace el diseño, sin funcionalidad.
203 Sección 13
Ahora mete funcionalidad. 
Va a usar nuestro customHook useForm. Lo copia en la carpeta hooks

En el formulario añade lo siguiente
value={searcText} que viene del useForm
onChange={onInputChange} que viene del useForm
onSubmit={onSearchSubmit}
y define la función onSearchSubmit

Al hacer esto cuando le das al botoón en lugar de salir esto
http://localhost:5173/search?searchText=eeee
sale esto 
http://localhost:5173/search

para añadir a la url los queryparam hace una navegación a la misma página pero con query param  y el texto que ha escrito con el navigate:

navigate(`?query=${searchText}`);

Ahora pare leerlo usa el useLocation, que nos da el search de la url recibida, todo a partir del ?.
Para leer fácilmente el queryparam instala el paquete query-string

Se instala así yarn add query-string
Con el query-string hace un parse de Location.search

const location = useLocation();
  const query =queyString.parse(location.queryString);
  console.log(query);
  desectructura lo que viene 
  const {miQuery=''} = queryString.parse(location.search);

204 Sección 13
Ahora una vez tiene la palabra a buscar hace la búsqueda.
En helpers crea la función getHeroresByName que reciba el nombre
si es vacio devuelve un arreglo vacio.
205 sección 13
Ahora explica como mostrar el rótulo de no encontrado y el de encontrado cada uno 
cuando toque.
Explica de dos formas:

{
    ( miQuery === '')
    ?  <div className="alert alert-primary">Search a hero</div>
    : (heroes.length === 0)
      && <div className="alert alert-danger">No hero with <b>{miQuery}</b></div>
}

La segunda forma:
usa el display : 'none' no hidden,porque el hidden ocupa espacio en la pantalla.

const showSearch = (miQuery.length === 0);
const showError = (miQuery.length > 0) && heroes.length === 0;

<div className="alert alert-primary style={{display: showSearch? 'none':''}}">Search a hero</div>
<div className="alert alert-danger style={{display: showError? 'none':''}}">No hero with <b>{miQuery}</b></div>
        
        {
          heroes.map(hero => (
            <HeroCard key={hero.id} {...hero} />
          ))
        }


209 Sección 14 Protección de rutas

Va hacer que rutas de la aplicación sólo funcionen si estás autentificado.

¿Qué veremos en esta sección?

Rutas públicas

Rutas privadas

Login y logout - Sin backend aún

Recordar cuál fue la última ruta visitada para mejorar la experiencia de usuario.

Context

Reducer

Esta es una sección pequeña pero importante para trabajar las bases de la autenticación y protección de nuestra aplicación.
Además guardaremos en que pantalla estab cunado hace logout para cuando haga login volver

210 Explica que necesitaremos un contexto y crea el directorio vacio dentro de la parte de auth
y también un directorio types, con los nombres de las acciones. Comenta que el contexto lo necesitamos para mantener si que todos los componentes sepan si
ha hecho login o no.
Dentro de la carpeta auth crea una carpeta context y una carpeta types

211 Crea un archivo types.js  que contiene
export const types = {
    login: '[Auth] Login',
    logout: '[Auth] Logout'
}


y en la carpte context crea un archivo AuthContext.jsx que será un funciontal component
por exportará un functional componente, lo que hace es createContext.
Luego hace otro archivo AuthProvider.jsx que es otro functional component.
Este será el que pasará el contexto a los objetos:

import React from 'react'
import { AuthContext } from './AuthContext'

export const AuthProvider = ({children}) => {
  return (
    <AuthContext.Provider value={{}}>
        {children}
    </AuthContext.Provider>
  )
}

Crea otro archivo authReucer.js que contendrá el reducer, que es un estado y una acción,
y será lo que el AuthProvider guardará y compartirá.

Luego crea un arhivo index en la carptea context, para exportar los tres archivos Y
hacer poner el contexto accesible en el componente de primer nivel para queda
así todos lo tengan.
