tema 04
El software a instalar está en la página https://gist.github.com/Klerith/4a4abfd88a88b2d1f16efd95fea41362
instalo:
React Developer Tools, extensión de chrome
Redux DevTools, extensión de chrome
visual studio code
postman
mongo compass que es para gestionar base de datos mongo
git 
node
añadimos activitus Bar  para visual studio code, para poner la barra abajo
Temas que estoy usando en VSCode:
Monokai Night

Tokyo Night

Iconos

Instalaciones recomendadas sobre React
ES7 React/Redux

Simple React Snippets

Auto Close Tag
Tema 8
React es una librería declarativa, es muy eficiente solo renderiza lo que cambia.
Permite tener componentes con estados o no, así tenemos piezas más pequeñas.
Se puede usar en back, con movile

La mínima aplicación sería esta:

Esta linea de java script busca el elemento con nombre root
const divRoot = document.querySelector("#root')
En esta línea react escribe en ese elemento el hml indicado.
ReactDom.render(<h1>Hola Mundo</h1>), divRoot);

A esto se le llama JSX que mezcla js y xml


lo anterior podría escribirse sólo así

const h1Tag = document.createElement('h1',null,'Hola Mundo')

Tema 9
Crea una carpeta 01-intro-react crea un index.html dentro
Escribe ! y luego ctrl y le sale un html básico
vamos a https://gist.github.com/Klerith/b0111f52ba16451d095f38d4c995605b y copiamos 

    <!-- Cargat React -->
    <script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

añade 
const h1Tag = <h1> Hola, soy  { nombre } </h1>;
pero da error porque esto no es javascript sino jsx, mezcla de javascript y html
para que no de error le debemos decir a babel que lo traduzca a jsx:

<script type="text/babel">
</script>

Tema 10
Explica babel que sirve para que traduza un código javascript moderno a un javascript normal, para que los
navegadores funcione.

Sección 3 Conceptos de javascript
Tema 11
¿Qué aprenderemos en esta sección?

Generar la base sobre JavaScript
Constantes y variables Let
Template String
Objetos literales
Arreglos
Desestructruación * (sumamente importante)
Promesas
Fetch API
Ternarios
Async - Await
Mi objetivo aquí es que tengamos las bases que nos ayuden a que podamos diferenciar fácilmente qué es propio de React y qué es propio de JavaScript. Estos conceptos y ejercicios nos ayudarán a suavizar la curva de aprendizaje de React.

Tema 13
Explica como crear el esqueleto de una aplicación react,
desde esta página https://create-react-app.dev/.
Existe otro proyecto que hace algo similar se llama vite https://vitejs.dev/guide/ (npm create vite@latest)
nos indica que ejecutemos en la linea de comandos el comando:
 npx create-react-app 02-intro-javascript
esto nos crea una carpeta con todo lo necesario para nuestra aplicación react.
si npx no está instalado node nos pregunta que lo instalemos
a mi me pide conectarme a github, lo hago y se instalado
luego aho cd a 02-intro-javascript y me abre un servidor node y un navegador que apunta a http://localhost:3000/

Tema 14
explica variables y constantes.
Declaración de variables:
const son variables que no se van a cambiar
let  son variables que cambian de valor.
var ya no se usa.

crea un index.js que luego copia y renombra en la carpeta bases a 01-const-let.js
El original lo deja vacio

Tema 15 Template String

sirve para poner concatener strings, poner variables dentro de strings etc..
El template string son los que van entre el simbolo `, dentro podemos mezclar
strings y javascript. El java script va dentro de ${}, además si hacemos
saltos de linea estos se incorporan al string.

const nombreCompleto = `${nombre} ${apellido} ${1+1}`;

Al final hace una copia en bases con nombre 02-template-string.js

Tema 16 Objetos literales

un objeto en javascript van entre llames
const perona = {

};
tenemos el objeto persona. Le ponemos propiedades

const persona = {
    nombre: 'Toni',
    edad:45,
}

console.log( { persona }) --> estamos creando un objeto nuevo que tiene 
una propiedad persona
console.table (persona)

const persona2 = persona;

hace una copia de referencia.

const persona2 = { ...persona};

hace una copia por valor

Tema 16 Arreglos
Es una colección de información dentro de una variable

const arreglo = new Array();

const arreglo = [];
arreglo.push(1);
arreglo.push(2);
El console.log los muestra con [], cuando es un objeto es {}
Para poner valores se puede usar push, 

Hace uso de nuevo de ..., que es lo que llama operador spread. 
Este operador lo que hace es leer el objeto que le acompaña y copiarlo parte a parte.

Dice que consultemos la página 
https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/map

Explica el método map de los arreglos.
Este método lo que hace es dada una función, la aplica sobre cada elemento del arreglo
origen y genera un nuevo arreglo con los nuevos valores:

por ejemplo una copia podría hacerse:

const arreglo3 = arreglo2.map(function(valor){return valor});

una copia con el doble del valor original

const arreglo3 = arreglo2.map(function(valor){return 2*valor});

una copia que sólo tendría tantas veces la palabra hola, como elmentos
tenga el arreglo original
const arreglo3 = arreglo2.map(function(){return 'hola'});



Tema 18 Funciones

function saludar (nombre) {
    return `Hola, ${nombre}`
}

console.log(saludar('Oscar'))

Aconseja que la definamos como Constante, así no la podemos machacar:

const saludar = function(nombre) {
    return `Hola, ${nombre}`;
}

Ahora explica la función de flechas

const saludar2  = (nombre) => {
    return `Hola, ${nombre}`;
}

si la función sólo hace un return se puede hacer esto

const saludar2  = (nombre) => `Hola, ${nombre}`;

y si no tiene parámetros

const saludar4 = () => `Hola, ${nombre}`;

cuando retornamos un objeto tenemos que poner un parentesis

const getUser = () => ({uid:'ddd',username:'ppp'})

Tema 19 Desestructruación de Objetos o Asignación desestructurante

dice que miremos esta página
https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment

Significa sacar los valores de los campos de un objeto de forma fácil.

Dado el objeto:

const persona = {
    nombre: 'Tony',
    edad: 45,
    clave: 'Ironman',
}

podemos sacarlo:
console.log(persona.nombre);
console.log(persona.edad);
console.log(persona.clave);

const { nombre, edad, clave} = persona;
console.log(nombre);
console.log(edad);
console.log(clave);

y si queremos renombrar algún campos

const { nombre:nombre2, edad:edad2, clave:clave2} = persona;
console.log(nombre2);
console.log(edad2);
console.log(clave2);

y si queremos coger los campos de dentro de un objeto que es un objeto se 
puede hacer de dos maneras:

const { nombreClave, anios, latlng: { lat, lng}} = persona;

o bien

const { nombreClave, anios, latlng} = persona;
const { lat, lng} = latlng;

cuando ponemos los : estamos diciendo que cree variables con el nombre de lo que 
hay a la derecha de los :. Por ejemplo

const {nombreClave:minombre, anios:misAnios, latlng: {lat,lng}} = avenger;
console.log(minombre, misAnios);
console.log (lat,lng);

Tema 20. Desestructruación de arreglos

Es sacar los valores en variables de un arreglo

const personajes =['Goku','Vegeta','Trunks']

const [  ,personaje2,personaje3 ]=personajes;

console.log(personaje2 personaje3);


const retornaArreglo = () => {
    return ['ABC',123];
}

const arr = retornaArreglo();
const [letras, numeros] = retornaArreglo();
console.log(letras,numeros)

//Tarea
//1. el primer valor de arreglo se llamará nombre
//2. el segundo se llamara setnombre
const useState = (valor) => {
    return [valor, ()=>{console.log('Hola Mundo')}]
}

const [nombre,setNombre] = useState('Goku');
console.log (nombre);
setNombre();

Sección 3. Tema 21

Nos pide crear un fichero en el directorio data con nombre heroes.js
que es un arreglo y contenido lo de este link 
https://gist.github.com/Klerith/4aeb99d31aedbc29ff4d54bbb77d2d7f

desde index.js quiere acceder:

import {heroes} from './data/heroes'

//pero para que funcione en heroes.js tenemos que poner un export

//Proponer hacer un ejercicio para que hacer que el siguiente código funcione,
//consultado el enlace : https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/find
const getHeroeById = (id) => {
    return heroes.find((elemento) => {
        console.log('id:', id);
        console.log('elemento:', elemento);
        return id===elemento.id});
}

console.log( getHeroeById(2))

//mejorado 

const getHeroeById2 = (id) => heroes.find((elemento) => id===elemento.id);


console.log( getHeroeById2(2))

//Ahora propone hacer funcionar el siguiente código, el caso es que el
// find no nos sirve porque ahora retornaremos más de un valor 
// dice que miremos la documentación para usar el Filter


const getHeroeByOwner = (owner) => heroes.filter((elemento) => owner===elemento.owner);

console.log( getHeroeByOwner('DC'));


arr[1]();

vuelve al tema de la exportación

dice que dado que el fichero sólo tiene la tabla
en lugar de exportarlo así:
export const heroes = [

e importar así:
import {heroes} from './data/heroes'

se puede poner

export default [

e importar así

import pepito from './data/heroes'

pero no le gusta

prefiere poner al final del fichero
export default heroes; al final del fichero
con export const heroes = [

otra cosa sobre la exportación, es cuando se exporta más de una cosa
y una de ellas es por defeco, entonces en la de importar
la que no tiene llave es la de por defecto y además podemos poner
el nombre que queramos en la importación directamente.
Si no es por defecto podemos cambiar el nombre así
import {heroes,owners as otro nombre} from './data/heroes'

export const owners = ['DC','Marvel];
export const heroes= ['DC','Marvel];

su import sería
import {heroes,owners} from './data/heroes'

si hacemos una por defecto, entonces no se ponen llaves

const heroes = ['DC','Marvel];

export const owners = ['DC','Marvel];
export default heroes;

import heroes,{owners} from './data/heroes'

también es análogo 

export {
    heroes as default,
    owners,
}


Sección 3 Tema 23 Promesas

const promesa = new Promise();

son asincronas, se ejecuta después de lo sincrono.

Indica la documentación a revisar: https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Promise

Las promesas recibe de parámetros que son callback.
El primero se ejecuta cuando este ok, y el segundo cuando falle

const promesa = new Promise ( 
    
    (resuelto,noResuelto) => {
    
        setTimeout(() => {
            resuelto();    
        }, 2000);
    
        ;
    }
)
//si pongo la llamada al método resuelto, que no está definido 
//la promesa no se cumple y el método then nunca se ejecuta

promesa.then( () =>{
    console.log('Then de la promesa')
})

Ahora pide que dentro del setTime haga un

const heroe = getHeroById(2);
console.log(heroe);

Ahora explica como pasarle argumentos a  la promesa. Esto
se hace poniendo la definición en la promesa dentro de una función

const miWrapper =(parametro) =>{
   return new Promise ( 
    
    (resuelto,noResuelto) => {
    
        setTimeout(() => {

            const heroe = getHeroeById(parametro);
            //console.log(heroe)
            resuelto(heroe);    
        }, 2000);
    
        ;
    }
)
}

miWrapper(3).then( p1 => console.log('Heroe',p1));

Ahora pide que añadamos el caso de error, y será cuando 
busquemos un indice que no existe

const miWrapper =(parametro) =>{
   return new Promise ( 
    
    (resuelto,noResuelto) => {
    
        setTimeout(() => {

            const heroe = getHeroeById(parametro);
            console.log('Dentro', heroe)
            if (heroe)  resuelto(heroe);
            else noResuelto(heroe);    
        }, 2000);
    
        ;
    }
)
}

miWrapper(2).then( p1 => console.log('Exito',p1))
.catch(p1 => console.log('Error',p1))

Comenta que podemos evitar escribir esto así

miWrapper(2).then( p1 => console.log('Exito',p1))
.catch(console.warm)

poniendolo así, dado que como sabemos que recibimos un sólo
parámetro y a la función le pasamos uno solo, javascript ya 
sabe lo que tienen que hacer

 //pide hacer lo mismo con el then
 miWrapper(2).then( console.log)
 .catch(console.warn)

 Sección 3. Tema 24 Fetch API

 es una librería interna, no hay que importar nada, recomienda
 leer esta página https://developer.mozilla.org/es/docs/Web/API/Fetch_API

 y para el ejemplo usaremos la siguiente web para disponer de una 
 api a la que llamamos y nos devuelve gifs que es esta:

 https://developers.giphy.com/ me doy de alta en la web con
 usuario rak0kso@gmail.com/rakG1kso

 creamos una aplicaicón tipo api, y nos quedamos con la apikey

 GeBZZMWXwYjyH2H5CxCKkZtXE2frfBzL

 buscamos en la documentación las api y cogemos la api Random EndPoint

 api.giphy.com/v1/gifs/random	

llamada de ejemplo 
https://api.giphy.com/v1/gifs/random?api_key=GeBZZMWXwYjyH2H5CxCKkZtXE2frfBzL

dado que fetch es una promesa que cuando se ejecuta ok nos devuelve 
la respuesta de la invocación a la url que le pasamos como argumento.
En el then le pasamos una función que coge esa respuesta y la devuelve en formato json.
Este formato json, también es una promesa que cuando se ejecuta nos devuelve
el forma json. Con ello cogemos la url de la imagen y la pintamos.

Sección 3 tema 25 Async Await

El Async hace que lo que se ejecute pueda ser sincrono.
El Await va siempre dentro del Async y con ello indicamos que el flujo
de ejecución se espere hasta que la sentencia se acabe.
Si ponemos el Await delante de la ejecución de una promesa conseguimos 
que esta sea sincrona.
Al hacer esto no hace falta que escribamos el then, ya nos retorna lo que calcula
la promesa.
Las promesas tenian el then para cuando iba ok, el catch cuando acaban ko, y el finally
para siempre. 
Cuando las ejecutamos de forma sincrona, para recoger los errores tenemos que
poner todo dentro de un try catch
Ahora lo que hace es reescribir el código del tema anterior, 
pero para que quede sincrono

Sección 3. Tema 26  Operación Ternarios

Es una forma corta de hacer un if.

const activo = true;

let mensaje = '';

if (activo) {
    mensaje = 'Activo';
} else {
    mensaje =' Inactivo';

}

console.log(mensaje);

se rescribe

const mensaje = (activo) ? 'Activo' : 'Inactivo';

Si no tenemos el else sería así;

const mensaje = (activo)&& 'Activo'

Recomienda leer para javascript esta web https://developer.mozilla.org/es/
y hacer su curso "JavaScript moderno"

Luego pasa la url del código que ha hecho 
https://github.com/Klerith/react-intro-javascript

Sección 4. Tema 1 introducción

¿Qué veremos en esta sección?

Nuestra primera aplicación - Hola Mundo

Exposiciones sobre los componentes

Creación de componentes (Functional Components)

Propiedades - Props

Impresiones en el HTML

PropTypes

DefaultProps

Introducción general a los Hooks

useState

Es una sección importante, especialmente para todos los que están empezando de cero en React, ya que dará las bases de cómo segmentar la lógica de nuestra aplicación en pequeñas piezas más fáciles de mantener.

Sección 4 Tema 32
Ahora crea la aplicación de ejemplo con create vite 

ejecuta dentro de la carpeta I:\udemy\repogit\cursoReact\udemy-react-de-cero-a-experto-hooks-y-mern
yarn create vite
pide un nombre de proyecto y le pone counter-app
pide que framework y le dice react

cuando acaba tenemos una carpeta que se llama counter-app
la renombra 03-counter-vite

luego ejecuta en ellas
yarn -->Esto instala las dependencias del proyecto
yarn dev


Nota: He tenido que crear instalar yarn
que se instala via npm: npm install --global yarn

usa yarn para dependencias locales y npm para dependencias globales ¿?
luego hacer lo mismo con create react
npx create-react-app counter-app

este es mas lento por que usa webapp para actualizar los componentes, y vite
utiliza otra  cosa
renombra la carpeta 03-counter-cra 

Sección 4 Estructura aplicación cra

se ve que fue creado por npm porque tiene el fichero package-lock.json
se crea con el npm install
en el package.json hay infomración interesante, como dependencias, el nombre del
proyecto, etc..

La carpeta public tiene el index.html que es donde se invocará  a nuestra aplicaicón

robots.txt es un fichero que usa google para analizar nuestra aplicación.
explicación de robots : https://developers.google.com/search/docs/crawling-indexing/robots/intro?hl=es&visit_id=638282342332022604-3099763398&rd=1

también pone estos dos enlaces
PWA Progressive web app: https://web.dev/learn/pwa/
ayuda de cra --> https://create-react-app.dev/docs/available-scripts/
app.js --> tiene el javascript
index.js --> es realmente un jpx, tiene html y javascript


Sección 4 Directorios de vite

tiene el package.json
yarn.lock indica que lo creamos con yarn.
tiene un main.jsx que es análogo al index.js

Sección 4 Tema 35 primera aplicación en react

usa carpeta de vite,
arranca la aplicación con yarn dev

borra todo lo del source y crea un fichero main.jsx
importa react, react-dom/client

todo en react funciona con componentes funcionales

function App() {
    return (<h1> hola Mundo</h1>)
}

ReactDOM.createRoot(document.getElementById('roo')).render(
    <React.StrictMode>
    <App/>
    </React.StrictMode>
)

Sección 4 Tema 35 crear primer componetente
el componente app lo había creado dentro del main.jsx, pero lo mueve a otro fichero
Crea un fichero HelloWorldApp.jsx
Mueve la función la exporta de forma unitaría y la importa.

Sección 4 Tema 36 tarea crear nuevo componente

Ahora propone que el componente no solo escriba un h1 sino que haga más html.
pero si ponemos dos lineas falla.
La primera solución es ponerlo todo dentro de un div, pero si lo ponemos dentro del div
nos genrará un div no deseado en la página
React permite enviar n sentencias con el tag <Fragment>

hace lo siguiente 
import {Fragment} from 'reac';

export const FirstApp = () => {
    return (
        <Fragment><h1>Hola</h1><p>subtitulo</p></Fragment>
    )
}

react permite hacer esto sin declararlo pero usando <>

export const FirstApp = () => {
    return (
        <><h1>Hola</h1><p>subtitulo</p></>
    )
}

Sin el import. React sólo permite retornar un nodo.

Sección 4 Tema 39 Impresión de variables en el HTML

Como pones javascript dentro del html se hace con {} siempre que 
el javascript no sea un objeto.

<h1>hola { 1*5 }</h1>
 o
 <>{1*5}</>

 el código javascript, debe estar fuera de la función del componente por Temas
 de rendimiento

Sección 4 Tema 40 Añadir estilos

crea un styles.css con
html, body {
    background-color: #021232A
    color: white
    font-falimy: Helvetica, Arial, sans-serif;
    font-size: 1.3rem;
    padding: 70px;
}
y luego en el main.jsx importa el fichero con 
import "./styles.css";

Sección 4 Tema 41 comunicación entre componentes - Props

son los parámetros que le podemos definir al a funcion que renderizan

Los parámetros siempre son un objeto por tanto quedaría

export const FirstApp = ( prop) =>

return <>
<h1>{prop.titulo}</h1>
</>

y en la llamada <FirstApp titulo="Hola Mundo"/>

además explica que en f12 en la pestaña de components podemos ver el parámetro y 
modificarlo

Sección 4 Tema 42 PropTypes

Es una funcionalidad que viene directa con cra y no con vite
El objetivo es hacer parámetros obligatorios.

import PropTypes from 'prop-types';
yarn add prop-types o npm install prop-types

Luego declara 

FirstApp.propTypes = {
    title : PropTypes.string; Indica que debe ser un string, provocando un warning por consola.
    title : PropTypes.string.isRequired; Indica que debe ser un string, provocando un warning por consola.


}

Sección 4 Tema 43 Default PropTypes

Podemos poner valores por defecto en la definición del functional componente

export function FirstApp( {titulo='vacio', subtitulo='subtitulo vacio', valor})

o bien podemos usar una propiedad de este que se llama defaultProps de la siguiente
manera para nuestro ejemplo.

FirstApp.defaultProps = {
    title: 'No hay título',
    subTitle: 'No hay subtitulo'
    nuevo:'Nuevo'
}

Sección 4 Tema 44 Tarea - ComponentCounter

Pide hacer el ejercicio que está en esta url:
https://gist.github.com/Klerith/e1a731cc595c00a9794a709062eae757

Sección 4 Tema 45 Evento Click

En react los eventos son unos objetos sinteticos que 
encapsulan los eventos de los navegadores y los homogenizan
para que se comporten en todos los navegadores igual.

En la pagina siguiente hay documentación : https://es.react.dev/reference/react-dom/components/common#react-event-object


Ahora añade un botón al componente que al recibir un onclick llama a una función

Comenta que la función si no hay referencia a nada del componente la podemos 
poner fuera, y eso hara el componente más ligero porque no la volverá a leer.
No necesitamos que se lea porque es una función que no cambia.

Explica que si en la función tocamos el parámetro que le llega al componente.
y lo pintamos veremos que no pasa nada. Esto es porque react aunque cambie
el valor del parámetro no lo redibuja porque no le hemos dicho que lo redibuje.
En cambio si hacemos un console.log el parámetro si cambio de valor.

Sección 4 Tema 46 useState

Habla de los hooks, hay muchos y en el fondo son funciones.
Comenta el useState que es un hook.
Los hooks aparece a partir de la versión 16.8
Comenta la documentación: https://es.legacy.reactjs.org/docs/hooks-intro.html

Los hooks cuando cambian provocan que se renderice, en el ejemplo anterior
aunque se incrementaba el valor no lo veíamos en la página porque react
no consideraba que había un cambio, los hooks hacen que react reconozca el cambio.

Los hooks puede ser de react o custom. De react hay unos cuantos y todos 
empizan por use: useState, useContext, use....

useState recibe un valor inicial del estado
y devuelve un valor final y una función a la que llamaremos 
para cambiar el valor.

const [ contador, actualizaContador ] = useState ( valorInicial);

actualizaContador(contador + 1)



Cada vez que cambia el estado se vuelve a ejecutar todo el functional component,
es decir la función CounterApp

Se puede demostrar poniendo un console.log en el componente,

Hacemos la función:

function restar(event) {
        console.log(event);
        //da error porque contador es una constante contador=contador +1;
        actualizaContador(contador -1);
        console.log(contador)
    }   


que se puede reescribir por
const restar = () ==> actualizaContador(contador -1);

Parece que el useState tiene acción después cuando se renderiza el componente.
Es decir, inicialmente el contador vale 2, si clico sumar 1, después de 
la función sumar 1, vale 2 igual que antes, pero después se renderiza el componente
pero ya con el nuevo valor 3.
Esto es así porque el useState es asincrono y el valor no se actualiza hasta que 
pasa un tiempo. 
Si se pone un dealy en el console.log se ve bien.

Tema 48 código de la sección
https://github.com/Klerith/react-vite-counter-app/tree/fin-seccion-4

Sección 5 Pruebas unitarias

¿Qué veremos en esta sección?

Introducción a las pruebas

AAA

Arrange - Arreglar

Act - Actuar

Assert - Afirmar

Primeras pruebas

Jest

Expect

toBe

Enzyme

Comandos útiles en la terminal para pruebas

Revisar elementos renderizados en el componente

Simular eventos

Esta sección de pruebas es sumamente importante porque nos dará la base de las pruebas que estaremos haciendo durante el curso, las pruebas irán creciendo en complejidad, por lo que les recomiendo que nos aseguremos de comprender bien todos estos conceptos para que nos sea más fácil las siguientes secciones de pruebas.

Sección 5. Tema 51 introducción

Arreglar: 
es incializar
Actuar:
aplicamos acciones
Afirmar:
observar el componrtamiento de las acciones

Tema 52
nos hace poner en src el código del tema 52 que es el de la primera parte del curso
template-string, funciones etc...

Sección 5 Tema 53
´
Como usamos vite tenemos que configurar las librerias de testing,
si vuer cra no haría falta.
Nos enseña la web de jest https://jestjs.io/
yarn add --dev jest
luego en package.json
añade el script test.

luego ejecuta yarn test
nos dará error porque no tenemos pruebas

Crea un directorio test en el src, y hace un espejo de los ficheros 
si tenemos un CounterApp.jsx tendremos un ConteerApp.test.js
le damos contenido

el fichero se llama demo.test.js, sino acaba con test.js no lo reconoce.

test('Esta prueba no debe falla', ()=>{

    aqui evaluamos cosas
})

Ahora tendría que ejecutar yarn test cada vez.
para que se ejecute en cada cambio  en el script ponermo 

yarn jest --watchAll

Tema 5 Tema 54

consultar documentación jest

Jest nos ayuda no hacer if en el codigo de test.

const message1 = 'Hola mundo';
const message2 = message1.trim();

en lugar de hacer
if (message1 === message2) throw exception

hariamos 
expect (message1).toBe(message2);

como el jest tiene muchos metodos y añade
yarn add -D @types/jest instala en desarrollo y el visual studio ya nos ayuda 

Sección 5 Tema 56
Ahora va a añadir test al archivo 02-template-string, para poder llamar a una
función que queremos testear tenemos que hacer un export de esta.
Además quita las otras varibles del archivo.

Crea un archivo espejo para probar la función.

No funciona porque jest no interpreta babel, tenemos que instalarlo y configurarlo

yarn add --dev babel-jest @babel/core @babel/preset-env

luego tocamos el fichero babel.config.js como dice la documentación
 https://jestjs.io/es-ES/docs/getting-started

 explica como hacer que no se ejecuten todos los archivos de test sino 
 solo el que estamos trabajando

 en yarn jest -watchAll
 clickamos w

 pero tuve que poner eston en powershell como administrador
 Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
 y el regexpr no me funciona

 Sección 5 Tema 57

 ahora hace test que comparan objetos java sobre el 05-funciones.
 se hace con expect ... toEqual

 Sección 5 Tema 58
 Hace un test que comprueba que devuelve un string o un número.
 explica que hay dos formas de hacerlo.
 una con typeof de javascript 

 expect(typeof miValor).toBe('String')

 o bien con puro jest que es un objeto cualquiera pero string.

 except ( mivalor).toEqual(expect.any(String));
 Sección 5 Tema 59
 Mas test ahora del fichero 08

 Sección 5 Tema 60
 Pruebas sobre las promesas 09

 Jest ejecuta todo secuencial, por lo que cuando ponemos una promesa, no espera que esta se ejecute

  const id = 1;
        getHeroeByIdAsync(id).then( heroe => {
            console.log('hola:', heroe);
            expect(true).toBe(false);
        }
        
        );
        console.log('adios')

Esta prueba pasa, escribe adios, no escribe hola, y cuando acaba dice que hay un worker fallado, se da cuenta
que hay cosas que no ha ejecutado.

 para que no lo haga, debemos pasarle un nombre
 que normalmente se le pone el nombre de done, el cree que es una función que llamará
 asumiendo que ha acabado,
 así que en lugar de poner 

 
 test('getHeroesByOwner debe retornar heroes de DC',()=>{
    ponemos
test('getHeroesByOwner debe retornar heroes de DC',(hecho)=>{
y en la promesa llamamos a hecho.

Con este test

   test('getHeroeByIdAsyncdebe retornar un heroe por i',(CuandoHecho)=>{

        const id = 1;
        getHeroeByIdAsync(id).then( heroe => {
            console.log('hola:', heroe);
            //expect(true).toBe(false);
            CuandoHecho();
        }
        
        );
        console.log('adios')

Sección 5 Tema 61 Pruebas async-await

 Cuando nosotros desde jest lanzamos :

  const url = async getImagen();

  se queja porque el async no lo reconoce, para que lo haga nos pide que hagamos  una serie de configuraciones.

  Para que funcione configura el jest. Para hacerlo, primero en el raíz crea un archivo llamado
  jest.config.js
  En este archivo declara una propiedad que se llama setupFiles con la que le indicamos un archivo (jest.setup.js)
  de javascript que debe ejecutar jest cada vez.
  En este archivo cargará los modulos que le permiten ejecutar el fetch que es lo que le molesta
  Antes instalamos via yarn este modulo para desarrollo con la opción -D
  yarn add -D whatwg-fetch
  en el fichero hace un import de este modulo
  import 'whatwg-fech';

Al final no he tenido que configurar nada, solo poner el async en la llamada

Al hacerlo la salida es así
 const id = 1;
        getHeroeByIdAsync(id).then( heroe => {
            console.log('hola:', heroe);
            expect(true).toBe(false);
        }
        
        );
        console.log('adios')


Sección 5 Tema 63
react testing library, es otro framework de testing
le gusta jest pero también quiere usar testing library porque es muy bueno para componentes
De hecho en la documentación de jest recomienda el uso de react testing library y dice como
instalarlo (https://jestjs.io/docs/tutorial-react#dom-testing, https://testing-library.com/)
yarn add -dev @testing-library/react

Sección 5 Tema 64
Ahora creamos un test para firstapp y en el test invocamos al render
de import { render } from '@testing-library/react'
pero da un error porque no sabe hacerlo para arreglarlo hace
en el jest.config.js añade
testEnvironment: 'jest-environment-jsdom',
e instala yarn add -dev jest-environment-jsdom
y en el babel.config

presets :[
    [@babel/preset-react',{runtime :'automatic'}]
]

e instala @babel/preset-react 
con yarn add -D @babel/preset-react

no me ha funcionado no lee el archivo jest.config.cjs, al final en el test 
he puesto lo siguiente

  /**
 * @jest-environment jsdom
 */

 para que pueda renderizar
 Tema 5 sección 65
 explica que el render nos ofrece un container y funciones.
 El container contiene el código html que genera el componente.
 Las funciones son funciones para buscar dentro del componente.
 También explica que es muy útil hacer un snapshot de lo que genera
 el componente esto se guarda en una carpeta y el test 
 comprueba que lo generado por el render es lo mismo. Si no lo es
 avisa e indica si queremos actualizar el render.
 el snapshot lo genera al ejecutar esta linea
  expect ( container ).toMatchSnapshot();
  jest guarda una foto y la comporar cada vez.


  Sección 5 Tema 66 getByTestId

Ahora del render coge la función getByTestId
En el código generado por el componente le pone un atributo
donde quiere con nombre data-testid="test_1" y luego con la función
getByTestid puede recuperar ese valor así, hacemos la prueba flexible.
No debe estar en un h1 sino en un sitio con este valor

Sección 5 Tema 67 screen

igual que el render, tenemos el screen que es el código html 
de la página, se dedica a hacer los mismos test pero usando el screen

Sección 6 Tema 68 Pruebas CounterApp
Ahora poque para que se renderice solo el CounterApp
pide que hagamos las pruebas de:
debe de hacer match con el snapshot
debe mostrar el valor inicial de 100

Sección 6 Tema 69 Simular eventos

Lo hace con fireEvent para disparar eventos.
podemos simular cualquier evento, simula el click sobre un
elemento de lo generado via screen

fireEvent.click(screen.getByText('+1'))
expect(screen.getByText('101')).toBeTruthy();

con screen.debug() nos mostrará como está el dom por pantalla

usa el atributo arial-label y luego lo usa
fireEvent.click(screen.getByRole('button',{name:'bnt-reset'}))

Sección 6 Temas
¿Qué veremos en esta sección?

Custom Hooks

Fetch hacia un API

Comunicación entre componentes

Clases de CSS

Animaciones

Enviar métodos como argumentos

Crear listados

keys

Giphy

Esta es una aplicación pequeña pero muy ilustrativa que explica cómo utilizar React + customHooks para poder resolver necesidades en específico que podremos re-utilizar después.

Sección 6 Tema 74

Crea una app
yarn create vite --> crea la aplicación
yarn install --> instala los modulos apm
yarn dev --> arranca


Sección 6 Tema 75
Añade estilos y explica como organizar los ficheros


https://es.legacy.reactjs.org/docs/faq-structure.html
https://hackernoon.com/structuring-projects-and-naming-components-in-react-1261b6e18d76

Sección 7 Tema 77
Crea una lista de tareas de categorias con ol, y la llena un useState
React guarda cada hook como una lista numerada y sabe cual es cual por el orden
en el que aparecen. 
Si declaramosun hook (useState) dentro de un if, esto va encontra de react.
No se debe hacer nunca
Sección 6 Tema 78
Hacer un boton que añada tareas.
useState y react:
//setCategories([ 'categoria1','categoria2','categoria3'] ); --> esto hace un bucle
        //y no funciona, y esto también setCategories(ategories.push("categoria3") )
        // tampoco funciona 
        // categories.push("categoria3");
        // setCategories(categories);
        // por que a react no le gusta que le toques la variable de estado. El push lo que hace es añadir
        // un valor alos existentes, pare evitar eso hay que hacer una nueva copia, modificar la copia,
        // y asignarla con el set, así le creas un nuevo estado.
        // por seo la solución es setCategories([ ...categories, 'Nuevo valor']); el comando hace una copia, y añade
        // un nuevo valor. 

        /* 
        ...categories, saca los valores, y [,] añadem por tanto para añadirla nueva al principio hacemos
        setCategories(['NuevoValor, ...categories])
        */

Tema 78

Ahora escribe un componente que será una caja de texto.
Primero lo hace con un input y el estado de este input

const [ inputValue, setInputValue] = useState('nuevo valor');

return (
    <input
    type="text"
    value={inputValue}
)

Esto no funciona, cuando escribimos en el input no pasa nada, no nos deja escribir.
Para solucionarlo le pone un onchage

const [ inputValue, setInputValue] = useState('nuevo valor');

const onInputChage = () => {
    setInputValue('hola');
}
return (
    <input
    type="text"
    value={inputValue}
    onChange= {onInputChange}
)

Esto tampoco funciona ahora cuando escribimos cambia a hola mundo.
Tenemos que coger el valor de lo que ha cambiado y asignarlo al estado.

const [ inputValue, setInputValue] = useState('nuevo valor');

const onInputChage = (event) => {
    setInputValue(event.target.value);
}
return (
    <input
    type="text"
    value={inputValue}
    onChange= {(event) => onInputChange(event)}
)

Pero queremos que cuando le demos a enter haga algo para ello pone 
el input dentro de un form que llame a una nueva función

const [ inputValue, setInputValue] = useState('nuevo valor');

const onInputChage = (event) => {
    setInputValue(event.target.value);
}

const onSubmit = (event) => {

}

return (
    <form onSubmit={ (event)} => onSubmit(event)}>
    <input
    type="text"
    value={inputValue}
    onChange= {(event) => onInputChange(event)}
    </form>
)

Pero el form lo que hace es recargar la página, para evitarlo
debe hacer un event.preventDefault en la función que llame el formulario.

const [ inputValue, setInputValue] = useState('nuevo valor');

const onInputChage = (event) => {
    setInputValue(event.target.value);
}

const onSubmit = (event) => {
    event.preventDefault();
}

return (
    <form onSubmit={ (event)} => onSubmit(event)}>
    <input
    type="text"
    value={inputValue}
    onChange= {(event) => onInputChange(event)}
    </form>
)

optimizando

const [ inputValue, setInputValue] = useState('nuevo valor');

const onInputChage = (event) => {
    setInputValue(event.target.value);
}

const onSubmit = (event) => {
    event.preventDefault();
}

return (
    <form onSubmit={ onSubmit(event)}>
    <input
    type="text"
    value={inputValue}
    onChange= { onInputChange(event)}
    </form>
)

Para escribir rápido un componente escribe rafc

Tema 79

Ahora pide quitar el botón de añadir literal y que desde el componente añadamos elmentos a la lista
Como pista sugiere pasar la función setCategories al componente.

La idea era pasar la función del useState del componente principal al de debajo  e invocarla
asignando el valor que obtiene el componente que está leyendo la info, pero esto no funciona
//no funciona da error GifExpertApp.jsx:45 Uncaught TypeError: categories.map is not a function
        //functionAddCategory(...inputValue); 
        
Debemos llamarlo, pero no con el valor a introducir, sino con una función para que react
lo actualice correctamente se intenta explicar en esta página pero no me queda claro

https://es.react.dev/reference/react/useState#updating-state-based-on-the-previous-state

Dice que react no ejecuta la función inmediatamente, lo que hace es ponerla en cola resolviendo todos los valores que se le pasan
y luego la ejecuta secuencialmente.
Si hacemos que sea una función, entonces si que lo hace
de algún modo sabe que categories es el valor actual y lo debe actualizar con el input

En una respuesta el profesor dice
Recuerda que la función set (el segundo elemento del array que desestructuramos del useState, 
en este caso setCategories en el GifExpertApp.jsx) puede recibir como argumento un valor determinado para actualizar el estado o una función actualizadora, 
que tiene como argumento el estado previo.

Tema 80

Ahora tenemos el GifExpert que es el padre y tiene un hijo que es el addCategory.
El padre le pasa al hijo la función del useState y este tiene que saber que le están pasando un useStates.
En realidad lo correcto sería qu el hijo, donde delegamos la captura de una categoria no supiera nada y que devolviera el useState.


ahora lo que hace es al reves que el componente que tiene el input devuelva el valor
para ello invoca al componente que tiene el input pasandole una función del tipo (value) => onAddCategory(value) , que resumido queda como onAddCategory
y en el componente invocamos a esta función.


        functionAddCategory((categories)=> [inputValue,...categories])

La función que pasará ahora al hijo la llama onAddCategory,para darle la semantia que emite algo

onNewCategory={ (valor) => onAddCategory(valor)} es decir el hijo tiene una propiedad 
llamada onNewCategory que será una función a la que llamará.


81 Quiere evitar que enviemos 2 valores iguales
lo hace en el gifexpertapps

82
Creo un nuevo componente para mostrar la lista de categorias.
El componente se llama GifGrid, recibe como parámetro la categoria buscar
y renderiza los resultados de esa búsqueda.

83 Feth API obtener imágnes 

crea dentro del GifGrid una función que va a buscar la url del gif.
 y luego llama a esta función dentro del webcomponent.
 Esto hace que siempre se llame dos veces a la función.
 Nunca debemos poner dentro del webcomponent una función sino se ejecutará de forma
 incontrolada.

Para remediarlo se debe usar el useEfect
Para acabar mueve la función a otro fichero.

84 useEffect

React renderiza los componentes, funtional component cada vez que detecta un cambio.
Si dentro del componente tenemos una función esta se ejecutará de nuevo.
Además react en StrictMode ejecuta dos veces los componentes.

Para evitar que lo ejecute la segunda vez lo quitamos.
React.StrictMode
Este modo en produción no aplica.

Para eviatar que lo ejecute la primera vez usa el useEffect.
El useEffect se le pasa la función que queremos que se ejecute solo sobre algunas condiciones
y luego le pasa la lista de condiciones. si le pasamos una lista vacia asume que 
sólo se debe ejecutar cuando se crea el componente.

useEffect(() => {getGifs(category)},[])

La función llama a nuestro getGifs, cuando []

85 Demostración de un build a producción
el modo StrictMode lo hace react para validar y sólo lo hace en desarrollo.
Para generar el build de producción
yarn build
esto genera una carpeta dist que está el código a copiar a pro.
Luego lo copia en un httpserver y vemos que no se reptie la llamada

87 mostrar títulos de las imágenes


Quiere mostrar los títulos de las imágenes.
Dado que queremos que se refresque

cuando nosotros usamos el async estamos indicando que es una promesa.
el useEffect espera una función,no una promesa por ello desde el
useEffect no podemos llamar al getGifs para obtener los gifs de la categoria y
guardarlos en el useState.

Si desde la promesa llamamos directamente al getGifs como tiene un async implica que es una promesa,
y lo que pasa es que no acaba de ejecutarse, para mitigarlo lo que hace es hacer el then

 useEffect(() => {

    const newImages= getGifs(category);
    
  
    getGifs(category).then( newImages => setImages(newImages));
    
    //console.log("imagenes",newImages);
  },[])
El useEffect sólo puede tener una linea, si pongo dos no funciona ni aunque sea un console.log

luego para mejorarlo crea una función que hace todo esto:

const getImages = async() => {
    const newImages = await getGifs(category);
    setImages(newImages);
}

useEffect(() => {

    const newImages= getImages();
  
  
  },[])
https://react.dev/learn/state-a-components-memory
87 spread y componente gifItem
En jsx no se puede poner class para los css, se debe usar className
le pone la key al nuevo componente porque react se queja todo los componentes tienen que tener un id.
En esta clase crea un componente que será el encargado de pintar cada elemento de los gifs que hemos obtenido.
El componente se llama GifItem

para pasar los parámetros al componente usa lo que se llama spread

en lugar de escribir 
<GifItem
key= {image.id}
title={image.title}
url= {image.url}
/>

hace esto
<GifItem
key= {image.id}
{...image}
/>

88 CustomHook  useFetchGifs
Ahora para simplificar el componente GifGrid, crea un customHook
Un hook al final es una función y es lo que hace crea una función
que retorna un objeto con dos campos images y isLoading.
Esta función la crea en otro archivo js

89 Mostrar mensaje de cargará
a partir del customhook que retorna si está cargando o no.
{
    isLoading && ( <h2>Cargando...</h2>)
}
