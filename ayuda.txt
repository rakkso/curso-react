tema 04
El software a instalar está en la página https://gist.github.com/Klerith/4a4abfd88a88b2d1f16efd95fea41362
instalo:
React Developer Tools, extensión de chrome
Redux DevTools, extensión de chrome
visual studio code
postman
mongo compass que es para gestionar base de datos mongo
git 
node
añadimos activitus Bar  para visual studio code, para poner la barra abajo
Temas que estoy usando en VSCode:
Monokai Night

Tokyo Night

Iconos

Instalaciones recomendadas sobre React
ES7 React/Redux

Simple React Snippets

Auto Close Tag
Tema 8
React es una librería declarativa, es muy eficiente solo renderiza lo que cambia.
Permite tener componentes con estados o no, así tenemos piezas más pequeñas.
Se puede usar en back, con movile

La mínima aplicación sería esta:

Esta linea de java script busca el elemento con nombre root
const divRoot = document.querySelector("#root')
En esta línea react escribe en ese elemento el hml indicado.
ReactDom.render(<h1>Hola Mundo</h1>), divRoot);

A esto se le llama JSX que mezcla js y xml


lo anterior podría escribirse sólo así

const h1Tag = document.createElement('h1',null,'Hola Mundo')

Tema 9
Crea una carpeta 01-intro-react crea un index.html dentro
Escribe ! y luego ctrl y le sale un html básico
vamos a https://gist.github.com/Klerith/b0111f52ba16451d095f38d4c995605b y copiamos 

    <!-- Cargat React -->
    <script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

añade 
const h1Tag = <h1> Hola, soy  { nombre } </h1>;
pero da error porque esto no es javascript sino jsx, mezcla de javascript y html
para que no de error le debemos decir a babel que lo traduzca a jsx:

<script type="text/babel">
</script>

Tema 10
Explica babel que sirve para que traduza un código javascript moderno a un javascript normal, para que los
navegadores funcione.

Sección 3 Conceptos de javascript
Tema 11
¿Qué aprenderemos en esta sección?

Generar la base sobre JavaScript
Constantes y variables Let
Template String
Objetos literales
Arreglos
Desestructruación * (sumamente importante)
Promesas
Fetch API
Ternarios
Async - Await
Mi objetivo aquí es que tengamos las bases que nos ayuden a que podamos diferenciar fácilmente qué es propio de React y qué es propio de JavaScript. Estos conceptos y ejercicios nos ayudarán a suavizar la curva de aprendizaje de React.

Tema 13
Explica como crear el esqueleto de una aplicación react,
desde esta página https://create-react-app.dev/.
Existe otro proyecto que hace algo similar se llama vite https://vitejs.dev/guide/ (npm create vite@latest)
nos indica que ejecutemos en la linea de comandos el comando:
 npx create-react-app 02-intro-javascript
esto nos crea una carpeta con todo lo necesario para nuestra aplicación react.
si npx no está instalado node nos pregunta que lo instalemos
a mi me pide conectarme a github, lo hago y se instalado
luego aho cd a 02-intro-javascript y me abre un servidor node y un navegador que apunta a http://localhost:3000/

Tema 14
explica variables y constantes.
Declaración de variables:
const son variables que no se van a cambiar
let  son variables que cambian de valor.
var ya no se usa.

crea un index.js que luego copia y renombra en la carpeta bases a 01-const-let.js
El original lo deja vacio

Tema 15 Template String

sirve para poner concatener strings, poner variables dentro de strings etc..
El template string son los que van entre el simbolo `, dentro podemos mezclar
strings y javascript. El java script va dentro de ${}, además si hacemos
saltos de linea estos se incorporan al string.

const nombreCompleto = `${nombre} ${apellido} ${1+1}`;

Al final hace una copia en bases con nombre 02-template-string.js

Tema 16 Objetos literales

un objeto en javascript van entre llames
const perona = {

};
tenemos el objeto persona. Le ponemos propiedades

const persona = {
    nombre: 'Toni',
    edad:45,
}

console.log( { persona }) --> estamos creando un objeto nuevo que tiene 
una propiedad persona
console.table (persona)

const persona2 = persona;

hace una copia de referencia.

const persona2 = { ...persona};

hace una copia por valor

Tema 16 Arreglos
Es una colección de información dentro de una variable

const arreglo = new Array();

const arreglo = [];
arreglo.push(1);
arreglo.push(2);
El console.log los muestra con [], cuando es un objeto es {}
Para poner valores se puede usar push, 

Hace uso de nuevo de ..., que es lo que llama operador spread. 
Este operador lo que hace es leer el objeto que le acompaña y copiarlo parte a parte.

Dice que consultemos la página 
https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/map

Explica el método map de los arreglos.
Este método lo que hace es dada una función, la aplica sobre cada elemento del arreglo
origen y genera un nuevo arreglo con los nuevos valores:

por ejemplo una copia podría hacerse:

const arreglo3 = arreglo2.map(function(valor){return valor});

una copia con el doble del valor original

const arreglo3 = arreglo2.map(function(valor){return 2*valor});

una copia que sólo tendría tantas veces la palabra hola, como elmentos
tenga el arreglo original
const arreglo3 = arreglo2.map(function(){return 'hola'});



Tema 18 Funciones

function saludar (nombre) {
    return `Hola, ${nombre}`
}

console.log(saludar('Oscar'))

Aconseja que la definamos como Constante, así no la podemos machacar:

const saludar = function(nombre) {
    return `Hola, ${nombre}`;
}

Ahora explica la función de flechas

const saludar2  = (nombre) => {
    return `Hola, ${nombre}`;
}

si la función sólo hace un return se puede hacer esto

const saludar2  = (nombre) => `Hola, ${nombre}`;

y si no tiene parámetros

const saludar4 = () => `Hola, ${nombre}`;

cuando retornamos un objeto tenemos que poner un parentesis

const getUser = () => ({uid:'ddd',username:'ppp'})

Tema 19 Desestructruación de Objetos o Asignación desestructurante

dice que miremos esta página
https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment

Significa sacar los valores de los campos de un objeto de forma fácil.

Dado el objeto:

const persona = {
    nombre: 'Tony',
    edad: 45,
    clave: 'Ironman',
}

podemos sacarlo:
console.log(persona.nombre);
console.log(persona.edad);
console.log(persona.clave);

const { nombre, edad, clave} = persona;
console.log(nombre);
console.log(edad);
console.log(clave);

y si queremos renombrar algún campos

const { nombre:nombre2, edad:edad2, clave:clave2} = persona;
console.log(nombre2);
console.log(edad2);
console.log(clave2);

y si queremos coger los campos de dentro de un objeto que es un objeto se 
puede hacer de dos maneras:

const { nombreClave, anios, latlng: { lat, lng}} = persona;

o bien

const { nombreClave, anios, latlng} = persona;
const { lat, lng} = latlng;

cuando ponemos los : estamos diciendo que cree variables con el nombre de lo que 
hay a la derecha de los :. Por ejemplo

const {nombreClave:minombre, anios:misAnios, latlng: {lat,lng}} = avenger;
console.log(minombre, misAnios);
console.log (lat,lng);

Tema 20. Desestructruación de arreglos

Es sacar los valores en variables de un arreglo

const personajes =['Goku','Vegeta','Trunks']

const [  ,personaje2,personaje3 ]=personajes;

console.log(personaje2 personaje3);


const retornaArreglo = () => {
    return ['ABC',123];
}

const arr = retornaArreglo();
const [letras, numeros] = retornaArreglo();
console.log(letras,numeros)

//Tarea
//1. el primer valor de arreglo se llamará nombre
//2. el segundo se llamara setnombre
const useState = (valor) => {
    return [valor, ()=>{console.log('Hola Mundo')}]
}

const [nombre,setNombre] = useState('Goku');
console.log (nombre);
setNombre();

Sección 3. Tema 21

Nos pide crear un fichero en el directorio data con nombre heroes.js
que es un arreglo y contenido lo de este link 
https://gist.github.com/Klerith/4aeb99d31aedbc29ff4d54bbb77d2d7f

desde index.js quiere acceder:

import {heroes} from './data/heroes'

//pero para que funcione en heroes.js tenemos que poner un export

//Proponer hacer un ejercicio para que hacer que el siguiente código funcione,
//consultado el enlace : https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/find
const getHeroeById = (id) => {
    return heroes.find((elemento) => {
        console.log('id:', id);
        console.log('elemento:', elemento);
        return id===elemento.id});
}

console.log( getHeroeById(2))

//mejorado 

const getHeroeById2 = (id) => heroes.find((elemento) => id===elemento.id);


console.log( getHeroeById2(2))

//Ahora propone hacer funcionar el siguiente código, el caso es que el
// find no nos sirve porque ahora retornaremos más de un valor 
// dice que miremos la documentación para usar el Filter


const getHeroeByOwner = (owner) => heroes.filter((elemento) => owner===elemento.owner);

console.log( getHeroeByOwner('DC'));


arr[1]();

vuelve al tema de la exportación

dice que dado que el fichero sólo tiene la tabla
en lugar de exportarlo así:
export const heroes = [

e importar así:
import {heroes} from './data/heroes'

se puede poner

export default [

e importar así

import pepito from './data/heroes'

pero no le gusta

prefiere poner al final del fichero
export default heroes; al final del fichero
con export const heroes = [

otra cosa sobre la exportación, es cuando se exporta más de una cosa
y una de ellas es por defeco, entonces en la de importar
la que no tiene llave es la de por defecto y además podemos poner
el nombre que queramos en la importación directamente.
Si no es por defecto podemos cambiar el nombre así
import {heroes,owners as otro nombre} from './data/heroes'

export const owners = ['DC','Marvel];
export const heroes= ['DC','Marvel];

su import sería
import {heroes,owners} from './data/heroes'

si hacemos una por defecto, entonces no se ponen llaves

const heroes = ['DC','Marvel];

export const owners = ['DC','Marvel];
export default heroes;

import heroes,{owners} from './data/heroes'

también es análogo 

export {
    heroes as default,
    owners,
}


Sección 3 Tema 23 Promesas

const promesa = new Promise();

son asincronas, se ejecuta después de lo sincrono.

Indica la documentación a revisar: https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Promise

Las promesas recibe de parámetros que son callback.
El primero se ejecuta cuando este ok, y el segundo cuando falle

const promesa = new Promise ( 
    
    (resuelto,noResuelto) => {
    
        setTimeout(() => {
            resuelto();    
        }, 2000);
    
        ;
    }
)
//si pongo la llamada al método resuelto, que no está definido 
//la promesa no se cumple y el método then nunca se ejecuta

promesa.then( () =>{
    console.log('Then de la promesa')
})

Ahora pide que dentro del setTime haga un

const heroe = getHeroById(2);
console.log(heroe);

Ahora explica como pasarle argumentos a  la promesa. Esto
se hace poniendo la definición en la promesa dentro de una función

const miWrapper =(parametro) =>{
   return new Promise ( 
    
    (resuelto,noResuelto) => {
    
        setTimeout(() => {

            const heroe = getHeroeById(parametro);
            //console.log(heroe)
            resuelto(heroe);    
        }, 2000);
    
        ;
    }
)
}

miWrapper(3).then( p1 => console.log('Heroe',p1));

Ahora pide que añadamos el caso de error, y será cuando 
busquemos un indice que no existe

const miWrapper =(parametro) =>{
   return new Promise ( 
    
    (resuelto,noResuelto) => {
    
        setTimeout(() => {

            const heroe = getHeroeById(parametro);
            console.log('Dentro', heroe)
            if (heroe)  resuelto(heroe);
            else noResuelto(heroe);    
        }, 2000);
    
        ;
    }
)
}

miWrapper(2).then( p1 => console.log('Exito',p1))
.catch(p1 => console.log('Error',p1))

Comenta que podemos evitar escribir esto así

miWrapper(2).then( p1 => console.log('Exito',p1))
.catch(console.warm)

poniendolo así, dado que como sabemos que recibimos un sólo
parámetro y a la función le pasamos uno solo, javascript ya 
sabe lo que tienen que hacer

 //pide hacer lo mismo con el then
 miWrapper(2).then( console.log)
 .catch(console.warn)

 Sección 3. Tema 24 Fetch API

 es una librería interna, no hay que importar nada, recomienda
 leer esta página https://developer.mozilla.org/es/docs/Web/API/Fetch_API

 y para el ejemplo usaremos la siguiente web para disponer de una 
 api a la que llamamos y nos devuelve gifs que es esta:

 https://developers.giphy.com/ me doy de alta en la web con
 usuario rak0kso@gmail.com/rakG1kso

 creamos una aplicaicón tipo api, y nos quedamos con la apikey

 GeBZZMWXwYjyH2H5CxCKkZtXE2frfBzL

 buscamos en la documentación las api y cogemos la api Random EndPoint

 api.giphy.com/v1/gifs/random	

llamada de ejemplo 
https://api.giphy.com/v1/gifs/random?api_key=GeBZZMWXwYjyH2H5CxCKkZtXE2frfBzL

dado que fetch es una promesa que cuando se ejecuta ok nos devuelve 
la respuesta de la invocación a la url que le pasamos como argumento.
En el then le pasamos una función que coge esa respuesta y la devuelve en formato json.
Este formato json, también es una promesa que cuando se ejecuta nos devuelve
el forma json. Con ello cogemos la url de la imagen y la pintamos.

Sección 3 tema 25 Async Await

El Async hace que lo que se ejecute pueda ser sincrono.
El Await va siempre dentro del Async y con ello indicamos que el flujo
de ejecución se espere hasta que la sentencia se acabe.
Si ponemos el Await delante de la ejecución de una promesa conseguimos 
que esta sea sincrona.
Al hacer esto no hace falta que escribamos el then, ya nos retorna lo que calcula
la promesa.
Las promesas tenian el then para cuando iba ok, el catch cuando acaban ko, y el finally
para siempre. 
Cuando las ejecutamos de forma sincrona, para recoger los errores tenemos que
poner todo dentro de un try catch
Ahora lo que hace es reescribir el código del tema anterior, 
pero para que quede sincrono

Sección 3. Tema 26  Operación Ternarios

Es una forma corta de hacer un if.

const activo = true;

let mensaje = '';

if (activo) {
    mensaje = 'Activo';
} else {
    mensaje =' Inactivo';

}

console.log(mensaje);

se rescribe

const mensaje = (activo) ? 'Activo' : 'Inactivo';

Si no tenemos el else sería así;

const mensaje = (activo)&& 'Activo'

Recomienda leer para javascript esta web https://developer.mozilla.org/es/
y hacer su curso "JavaScript moderno"

Luego pasa la url del código que ha hecho 
https://github.com/Klerith/react-intro-javascript

Sección 4. Tema 1 introducción

¿Qué veremos en esta sección?

Nuestra primera aplicación - Hola Mundo

Exposiciones sobre los componentes

Creación de componentes (Functional Components)

Propiedades - Props

Impresiones en el HTML

PropTypes

DefaultProps

Introducción general a los Hooks

useState

Es una sección importante, especialmente para todos los que están empezando de cero en React, ya que dará las bases de cómo segmentar la lógica de nuestra aplicación en pequeñas piezas más fáciles de mantener.

Sección 4 Tema 32
Ahora crea la aplicación de ejemplo con create vite 

ejecuta dentro de la carpeta I:\udemy\repogit\cursoReact\udemy-react-de-cero-a-experto-hooks-y-mern
yarn create vite
pide un nombre de proyecto y le pone counter-app
pide que framework y le dice react

cuando acaba tenemos una carpeta que se llama counter-app
la renombra 03-counter-vite

luego ejecuta en ellas
yarn -->Esto instala las dependencias del proyecto
yarn dev


Nota: He tenido que crear instalar yarn
que se instala via npm: npm install --global yarn

usa yarn para dependencias locales y npm para dependencias globales ¿?
luego hacer lo mismo con create react
npx create-react-app counter-app

este es mas lento por que usa webapp para actualizar los componentes, y vite
utiliza otra  cosa
renombra la carpeta 03-counter-cra 

Sección 4 Estructura aplicación cra

se ve que fue creado por npm porque tiene el fichero package-lock.json
se crea con el npm install
en el package.json hay infomración interesante, como dependencias, el nombre del
proyecto, etc..

La carpeta public tiene el index.html que es donde se invocará  a nuestra aplicaicón

robots.txt es un fichero que usa google para analizar nuestra aplicación.
explicación de robots : https://developers.google.com/search/docs/crawling-indexing/robots/intro?hl=es&visit_id=638282342332022604-3099763398&rd=1

también pone estos dos enlaces
PWA Progressive web app: https://web.dev/learn/pwa/
ayuda de cra --> https://create-react-app.dev/docs/available-scripts/
app.js --> tiene el javascript
index.js --> es realmente un jpx, tiene html y javascript


Sección 4 Directorios de vite

tiene el package.json
yarn.lock indica que lo creamos con yarn.
tiene un main.jsx que es análogo al index.js

Sección 4 Tema 35 primera aplicación en react

usa carpeta de vite,
arranca la aplicación con yarn dev

borra todo lo del source y crea un fichero main.jsx
importa react, react-dom/client

todo en react funciona con componentes funcionales

function App() {
    return (<h1> hola Mundo</h1>)
}

ReactDOM.createRoot(document.getElementById('roo')).render(
    <React.StrictMode>
    <App/>
    </React.StrictMode>
)

Sección 4 Tema 35 crear primer componetente
el componente app lo había creado dentro del main.jsx, pero lo mueve a otro fichero
Crea un fichero HelloWorldApp.jsx
Mueve la función la exporta de forma unitaría y la importa.

Sección 4 Tema 36 tarea crear nuevo componente

Ahora propone que el componente no solo escriba un h1 sino que haga más html.
pero si ponemos dos lineas falla.
La primera solución es ponerlo todo dentro de un div, pero si lo ponemos dentro del div
nos genrará un div no deseado en la página
React permite enviar n sentencias con el tag <Fragment>

hace lo siguiente 
import {Fragment} from 'reac';

export const FirstApp = () => {
    return (
        <Fragment><h1>Hola</h1><p>subtitulo</p></Fragment>
    )
}

react permite hacer esto sin declararlo pero usando <>

export const FirstApp = () => {
    return (
        <><h1>Hola</h1><p>subtitulo</p></>
    )
}

Sin el import. React sólo permite retornar un nodo.

Sección 4 Tema 39 Impresión de variables en el HTML

Como pones javascript dentro del html se hace con {} siempre que 
el javascript no sea un objeto.

<h1>hola { 1*5 }</h1>
 o
 <>{1*5}</>

 el código javascript, debe estar fuera de la función del componente por Temas
 de rendimiento

Sección 4 Tema 40 Añadir estilos

crea un styles.css con
html, body {
    background-color: #021232A
    color: white
    font-falimy: Helvetica, Arial, sans-serif;
    font-size: 1.3rem;
    padding: 70px;
}
y luego en el main.jsx importa el fichero con 
import "./styles.css";

Sección 4 Tema 41 comunicación entre componentes - Props

son los parámetros que le podemos definir al a funcion que renderizan

Los parámetros siempre son un objeto por tanto quedaría

export const FirstApp = ( prop) =>

return <>
<h1>{prop.titulo}</h1>
</>

y en la llamada <FirstApp titulo="Hola Mundo"/>

además explica que en f12 en la pestaña de components podemos ver el parámetro y 
modificarlo

Sección 4 Tema 42 PropTypes

Es una funcionalidad que viene directa con cra y no con vite
El objetivo es hacer parámetros obligatorios.

import PropTypes from 'prop-types';
yarn add prop-types o npm install prop-types

Luego declara 

FirstApp.propTypes = {
    title : PropTypes.string; Indica que debe ser un string, provocando un warning por consola.
    title : PropTypes.string.isRequired; Indica que debe ser un string, provocando un warning por consola.


}

Sección 4 Tema 43 Default PropTypes

Podemos poner valores por defecto en la definición del functional componente

export function FirstApp( {titulo='vacio', subtitulo='subtitulo vacio', valor})

o bien podemos usar una propiedad de este que se llama defaultProps de la siguiente
manera para nuestro ejemplo.

FirstApp.defaultProps = {
    title: 'No hay título',
    subTitle: 'No hay subtitulo'
    nuevo:'Nuevo'
}

Sección 4 Tema 44 Tarea - ComponentCounter

Pide hacer el ejercicio que está en esta url:
https://gist.github.com/Klerith/e1a731cc595c00a9794a709062eae757

Sección 4 Tema 45 Evento Click

En react los eventos son unos objetos sinteticos que 
encapsulan los eventos de los navegadores y los homogenizan
para que se comporten en todos los navegadores igual.

En la pagina siguiente hay documentación : https://es.react.dev/reference/react-dom/components/common#react-event-object


Ahora añade un botón al componente que al recibir un onclick llama a una función

Comenta que la función si no hay referencia a nada del componente la podemos 
poner fuera, y eso hara el componente más ligero porque no la volverá a leer.
No necesitamos que se lea porque es una función que no cambia.

Explica que si en la función tocamos el parámetro que le llega al componente.
y lo pintamos veremos que no pasa nada. Esto es porque react aunque cambie
el valor del parámetro no lo redibuja porque no le hemos dicho que lo redibuje.
En cambio si hacemos un console.log el parámetro si cambio de valor.

Sección 4 Tema 46 useState

Habla de los hooks, hay muchos y en el fondo son funciones.
Comenta el useState que es un hook.
Los hooks aparece a partir de la versión 16.8
Comenta la documentación: https://es.legacy.reactjs.org/docs/hooks-intro.html

Los hooks cuando cambian provocan que se renderice, en el ejemplo anterior
aunque se incrementaba el valor no lo veíamos en la página porque react
no consideraba que había un cambio, los hooks hacen que react reconozca el cambio.

Los hooks puede ser de react o custom. De react hay unos cuantos y todos 
empizan por use: useState, useContext, use....

useState recibe un valor inicial del estado
y devuelve un valor final y una función a la que llamaremos 
para cambiar el valor.

const [ contador, actualizaContador ] = useState ( valorInicial);

actualizaContador(contador + 1)



Cada vez que cambia el estado se vuelve a ejecutar todo el functional component,
es decir la función CounterApp

Se puede demostrar poniendo un console.log en el componente,

Hacemos la función:

function restar(event) {
        console.log(event);
        //da error porque contador es una constante contador=contador +1;
        actualizaContador(contador -1);
        console.log(contador)
    }   


que se puede reescribir por
const restar = () ==> actualizaContador(contador -1);

Parece que el useState tiene acción después cuando se renderiza el componente.
Es decir, inicialmente el contador vale 2, si clico sumar 1, después de 
la función sumar 1, vale 2 igual que antes, pero después se renderiza el componente
pero ya con el nuevo valor 3.
Esto es así porque el useState es asincrono y el valor no se actualiza hasta que 
pasa un tiempo. 
Si se pone un dealy en el console.log se ve bien.

Tema 48 código de la sección
https://github.com/Klerith/react-vite-counter-app/tree/fin-seccion-4

Sección 5 Pruebas unitarias

¿Qué veremos en esta sección?

Introducción a las pruebas

AAA

Arrange - Arreglar

Act - Actuar

Assert - Afirmar

Primeras pruebas

Jest

Expect

toBe

Enzyme

Comandos útiles en la terminal para pruebas

Revisar elementos renderizados en el componente

Simular eventos

Esta sección de pruebas es sumamente importante porque nos dará la base de las pruebas que estaremos haciendo durante el curso, las pruebas irán creciendo en complejidad, por lo que les recomiendo que nos aseguremos de comprender bien todos estos conceptos para que nos sea más fácil las siguientes secciones de pruebas.

Sección 5. Tema 51 introducción

Arreglar: 
es incializar
Actuar:
aplicamos acciones
Afirmar:
observar el componrtamiento de las acciones

Tema 52
nos hace poner en src el código del tema 52 que es el de la primera parte del curso
template-string, funciones etc...

Sección 5 Tema 53
´
Como usamos vite tenemos que configurar las librerias de testing,
si vuer cra no haría falta.
Nos enseña la web de jest https://jestjs.io/
yarn add --dev jest
luego en package.json
añade el script test.

luego ejecuta yarn test
nos dará error porque no tenemos pruebas

Crea un directorio test en el src, y hace un espejo de los ficheros 
si tenemos un CounterApp.jsx tendremos un ConteerApp.test.js
le damos contenido

el fichero se llama demo.test.js, sino acaba con test.js no lo reconoce.

test('Esta prueba no debe falla', ()=>{

    aqui evaluamos cosas
})

Ahora tendría que ejecutar yarn test cada vez.
para que se ejecute en cada cambio  en el script ponermo 

yarn jest --watchAll

Tema 5 Tema 54

consultar documentación jest

Jest nos ayuda no hacer if en el codigo de test.

const message1 = 'Hola mundo';
const message2 = message1.trim();

en lugar de hacer
if (message1 === message2) throw exception

hariamos 
expect (message1).toBe(message2);

como el jest tiene muchos metodos y añade
yarn add -D @types/jest instala en desarrollo y el visual studio ya nos ayuda 

Sección 5 Tema 56
Ahora va a añadir test al archivo 02-template-string, para poder llamar a una
función que queremos testear tenemos que hacer un export de esta.
Además quita las otras varibles del archivo.

Crea un archivo espejo para probar la función.

No funciona porque jest no interpreta babel, tenemos que instalarlo y configurarlo

yarn add --dev babel-jest @babel/core @babel/preset-env

luego tocamos el fichero babel.config.js como dice la documentación
 https://jestjs.io/es-ES/docs/getting-started

 explica como hacer que no se ejecuten todos los archivos de test sino 
 solo el que estamos trabajando

 en yarn jest -watchAll
 clickamos w

 pero tuve que poner eston en powershell como administrador
 Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
 y el regexpr no me funciona

 Sección 5 Tema 57

 ahora hace test que comparan objetos java sobre el 05-funciones.
 se hace con expect ... toEqual

 Sección 5 Tema 58
 Hace un test que comprueba que devuelve un string o un número.
 explica que hay dos formas de hacerlo.
 una con typeof de javascript 

 expect(typeof miValor).toBe('String')

 o bien con puro jest que es un objeto cualquiera pero string.

 except ( mivalor).toEqual(expect.any(String));
 Sección 5 Tema 59
 Mas test ahora del fichero 08

 Sección 5 Tema 60
 Pruebas sobre las promesas 09

 Jest ejecuta todo secuencial, por lo que cuando ponemos una promesa, no espera que esta se ejecute

  const id = 1;
        getHeroeByIdAsync(id).then( heroe => {
            console.log('hola:', heroe);
            expect(true).toBe(false);
        }
        
        );
        console.log('adios')

Esta prueba pasa, escribe adios, no escribe hola, y cuando acaba dice que hay un worker fallado, se da cuenta
que hay cosas que no ha ejecutado.

 para que no lo haga, debemos pasarle un nombre
 que normalmente se le pone el nombre de done, el cree que es una función que llamará
 asumiendo que ha acabado,
 así que en lugar de poner 

 
 test('getHeroesByOwner debe retornar heroes de DC',()=>{
    ponemos
test('getHeroesByOwner debe retornar heroes de DC',(hecho)=>{
y en la promesa llamamos a hecho.

Con este test

   test('getHeroeByIdAsyncdebe retornar un heroe por i',(CuandoHecho)=>{

        const id = 1;
        getHeroeByIdAsync(id).then( heroe => {
            console.log('hola:', heroe);
            //expect(true).toBe(false);
            CuandoHecho();
        }
        
        );
        console.log('adios')

Sección 5 Tema 61 Pruebas async-await

 Cuando nosotros desde jest lanzamos :

  const url = async getImagen();

  se queja porque el async no lo reconoce, para que lo haga nos pide que hagamos  una serie de configuraciones.

  Para que funcione configura el jest. Para hacerlo, primero en el raíz crea un archivo llamado
  jest.config.js
  En este archivo declara una propiedad que se llama setupFiles con la que le indicamos un archivo (jest.setup.js)
  de javascript que debe ejecutar jest cada vez.
  En este archivo cargará los modulos que le permiten ejecutar el fetch que es lo que le molesta
  Antes instalamos via yarn este modulo para desarrollo con la opción -D
  yarn add -D whatwg-fetch
  en el fichero hace un import de este modulo
  import 'whatwg-fech';

Al final no he tenido que configurar nada, solo poner el async en la llamada

Al hacerlo la salida es así
 const id = 1;
        getHeroeByIdAsync(id).then( heroe => {
            console.log('hola:', heroe);
            expect(true).toBe(false);
        }
        
        );
        console.log('adios')


Sección 5 Tema 63
react testing library, es otro framework de testing
le gusta jest pero también quiere usar testing library porque es muy bueno para componentes
De hecho en la documentación de jest recomienda el uso de react testing library y dice como
instalarlo (https://jestjs.io/docs/tutorial-react#dom-testing, https://testing-library.com/)
yarn add -dev @testing-library/react

Sección 5 Tema 64
Ahora creamos un test para firstapp y en el test invocamos al render
de import { render } from '@testing-library/react'
pero da un error porque no sabe hacerlo para arreglarlo hace
en el jest.config.js añade
testEnvironment: 'jest-environment-jsdom',
e instala yarn add -dev jest-environment-jsdom
y en el babel.config

presets :[
    [@babel/preset-react',{runtime :'automatic'}]
]

e instala @babel/preset-react 
con yarn add -D @babel/preset-react

no me ha funcionado no lee el archivo jest.config.cjs, al final en el test 
he puesto lo siguiente

  /**
 * @jest-environment jsdom
 */

 para que pueda renderizar
 Tema 5 sección 65
 explica que el render nos ofrece un container y funciones.
 El container contiene el código html que genera el componente.
 Las funciones son funciones para buscar dentro del componente.
 También explica que es muy útil hacer un snapshot de lo que genera
 el componente esto se guarda en una carpeta y el test 
 comprueba que lo generado por el render es lo mismo. Si no lo es
 avisa e indica si queremos actualizar el render.
 el snapshot lo genera al ejecutar esta linea
  expect ( container ).toMatchSnapshot();
  jest guarda una foto y la comporar cada vez.


  Sección 5 Tema 66 getByTestId

Ahora del render coge la función getByTestId
En el código generado por el componente le pone un atributo
donde quiere con nombre data-testid="test_1" y luego con la función
getByTestid puede recuperar ese valor así, hacemos la prueba flexible.
No debe estar en un h1 sino en un sitio con este valor

Sección 5 Tema 67 screen

igual que el render, tenemos el screen que es el código html 
de la página, se dedica a hacer los mismos test pero usando el screen

Sección 6 Tema 68 Pruebas CounterApp
Ahora poque para que se renderice solo el CounterApp
pide que hagamos las pruebas de:
debe de hacer match con el snapshot
debe mostrar el valor inicial de 100

Sección 6 Tema 69 Simular eventos

Lo hace con fireEvent para disparar eventos.
podemos simular cualquier evento, simula el click sobre un
elemento de lo generado via screen

fireEvent.click(screen.getByText('+1'))
expect(screen.getByText('101')).toBeTruthy();

con screen.debug() nos mostrará como está el dom por pantalla

usa el atributo arial-label y luego lo usa
fireEvent.click(screen.getByRole('button',{name:'bnt-reset'}))

Sección 6 Temas
¿Qué veremos en esta sección?

Custom Hooks

Fetch hacia un API

Comunicación entre componentes

Clases de CSS

Animaciones

Enviar métodos como argumentos

Crear listados

keys

Giphy

Esta es una aplicación pequeña pero muy ilustrativa que explica cómo utilizar React + customHooks para poder resolver necesidades en específico que podremos re-utilizar después.

Sección 6 Tema 74

Crea una app
yarn create vite --> crea la aplicación
yarn install --> instala los modulos apm
yarn dev --> arranca


Sección 6 Tema 75
Añade estilos y explica como organizar los ficheros


https://es.legacy.reactjs.org/docs/faq-structure.html
https://hackernoon.com/structuring-projects-and-naming-components-in-react-1261b6e18d76

Sección 7 Tema 77
Crea una lista de tareas de categorias con ol, y la llena un useState
React guarda cada hook como una lista numerada y sabe cual es cual por el orden
en el que aparecen. 
Si declaramosun hook (useState) dentro de un if, esto va encontra de react.
No se debe hacer nunca
Sección 6 Tema 78
Hacer un boton que añada tareas.
useState y react:
//setCategories([ 'categoria1','categoria2','categoria3'] ); --> esto hace un bucle
        //y no funciona, y esto también setCategories(ategories.push("categoria3") )
        // tampoco funciona 
        // categories.push("categoria3");
        // setCategories(categories);
        // por que a react no le gusta que le toques la variable de estado. El push lo que hace es añadir
        // un valor alos existentes, pare evitar eso hay que hacer una nueva copia, modificar la copia,
        // y asignarla con el set, así le creas un nuevo estado.
        // por seo la solución es setCategories([ ...categories, 'Nuevo valor']); el comando hace una copia, y añade
        // un nuevo valor. 

        /* 
        ...categories, saca los valores, y [,] añadem por tanto para añadirla nueva al principio hacemos
        setCategories(['NuevoValor, ...categories])
        */

Tema 78

Ahora escribe un componente que será una caja de texto.
Primero lo hace con un input y el estado de este input

const [ inputValue, setInputValue] = useState('nuevo valor');

return (
    <input
    type="text"
    value={inputValue}
)

Esto no funciona, cuando escribimos en el input no pasa nada, no nos deja escribir.
Para solucionarlo le pone un onchage

const [ inputValue, setInputValue] = useState('nuevo valor');

const onInputChage = () => {
    setInputValue('hola');
}
return (
    <input
    type="text"
    value={inputValue}
    onChange= {onInputChange}
)

Esto tampoco funciona ahora cuando escribimos cambia a hola mundo.
Tenemos que coger el valor de lo que ha cambiado y asignarlo al estado.

const [ inputValue, setInputValue] = useState('nuevo valor');

const onInputChage = (event) => {
    setInputValue(event.target.value);
}
return (
    <input
    type="text"
    value={inputValue}
    onChange= {(event) => onInputChange(event)}
)

Pero queremos que cuando le demos a enter haga algo para ello pone 
el input dentro de un form que llame a una nueva función

const [ inputValue, setInputValue] = useState('nuevo valor');

const onInputChage = (event) => {
    setInputValue(event.target.value);
}

const onSubmit = (event) => {

}

return (
    <form onSubmit={ (event)} => onSubmit(event)}>
    <input
    type="text"
    value={inputValue}
    onChange= {(event) => onInputChange(event)}
    </form>
)

Pero el form lo que hace es recargar la página, para evitarlo
debe hacer un event.preventDefault en la función que llame el formulario.

const [ inputValue, setInputValue] = useState('nuevo valor');

const onInputChage = (event) => {
    setInputValue(event.target.value);
}

const onSubmit = (event) => {
    event.preventDefault();
}

return (
    <form onSubmit={ (event)} => onSubmit(event)}>
    <input
    type="text"
    value={inputValue}
    onChange= {(event) => onInputChange(event)}
    </form>
)

optimizando

const [ inputValue, setInputValue] = useState('nuevo valor');

const onInputChage = (event) => {
    setInputValue(event.target.value);
}

const onSubmit = (event) => {
    event.preventDefault();
}

return (
    <form onSubmit={ onSubmit(event)}>
    <input
    type="text"
    value={inputValue}
    onChange= { onInputChange(event)}
    </form>
)

Para escribir rápido un componente escribe rafc

Tema 79

Ahora pide quitar el botón de añadir literal y que desde el componente añadamos elmentos a la lista
Como pista sugiere pasar la función setCategories al componente.

La idea era pasar la función del useState del componente principal al de debajo  e invocarla
asignando el valor que obtiene el componente que está leyendo la info, pero esto no funciona
//no funciona da error GifExpertApp.jsx:45 Uncaught TypeError: categories.map is not a function
        //functionAddCategory(...inputValue); 
        
Debemos llamarlo, pero no con el valor a introducir, sino con una función para que react
lo actualice correctamente se intenta explicar en esta página pero no me queda claro

https://es.react.dev/reference/react/useState#updating-state-based-on-the-previous-state

Dice que react no ejecuta la función inmediatamente, lo que hace es ponerla en cola resolviendo todos los valores que se le pasan
y luego la ejecuta secuencialmente.
Si hacemos que sea una función, entonces si que lo hace
de algún modo sabe que categories es el valor actual y lo debe actualizar con el input

En una respuesta el profesor dice
Recuerda que la función set (el segundo elemento del array que desestructuramos del useState, 
en este caso setCategories en el GifExpertApp.jsx) puede recibir como argumento un valor determinado para actualizar el estado o una función actualizadora, 
que tiene como argumento el estado previo.

Tema 80

Ahora tenemos el GifExpert que es el padre y tiene un hijo que es el addCategory.
El padre le pasa al hijo la función del useState y este tiene que saber que le están pasando un useStates.
En realidad lo correcto sería qu el hijo, donde delegamos la captura de una categoria no supiera nada y que devolviera el useState.


ahora lo que hace es al reves que el componente que tiene el input devuelva el valor
para ello invoca al componente que tiene el input pasandole una función del tipo (value) => onAddCategory(value) , que resumido queda como onAddCategory
y en el componente invocamos a esta función.


        functionAddCategory((categories)=> [inputValue,...categories])

La función que pasará ahora al hijo la llama onAddCategory,para darle la semantia que emite algo

onNewCategory={ (valor) => onAddCategory(valor)} es decir el hijo tiene una propiedad 
llamada onNewCategory que será una función a la que llamará.


81 Quiere evitar que enviemos 2 valores iguales
lo hace en el gifexpertapps

82
Creo un nuevo componente para mostrar la lista de categorias.
El componente se llama GifGrid, recibe como parámetro la categoria buscar
y renderiza los resultados de esa búsqueda.

83 Feth API obtener imágnes 

crea dentro del GifGrid una función que va a buscar la url del gif.
 y luego llama a esta función dentro del webcomponent.
 Esto hace que siempre se llame dos veces a la función.
 Nunca debemos poner dentro del webcomponent una función sino se ejecutará de forma
 incontrolada.

Para remediarlo se debe usar el useEfect
Para acabar mueve la función a otro fichero.

84 useEffect

React renderiza los componentes, funtional component cada vez que detecta un cambio.
Si dentro del componente tenemos una función esta se ejecutará de nuevo.
Además react en StrictMode ejecuta dos veces los componentes.

Para evitar que lo ejecute la segunda vez lo quitamos.
React.StrictMode
Este modo en produción no aplica.

Para eviatar que lo ejecute la primera vez usa el useEffect.
El useEffect se le pasa la función que queremos que se ejecute solo sobre algunas condiciones
y luego le pasa la lista de condiciones. si le pasamos una lista vacia asume que 
sólo se debe ejecutar cuando se crea el componente.

useEffect(() => {getGifs(category)},[])

La función llama a nuestro getGifs, cuando []

85 Demostración de un build a producción
el modo StrictMode lo hace react para validar y sólo lo hace en desarrollo.
Para generar el build de producción
yarn build
esto genera una carpeta dist que está el código a copiar a pro.
Luego lo copia en un httpserver y vemos que no se reptie la llamada

87 mostrar títulos de las imágenes


Quiere mostrar los títulos de las imágenes.
Dado que queremos que se refresque

cuando nosotros usamos el async estamos indicando que es una promesa.
el useEffect espera una función,no una promesa por ello desde el
useEffect no podemos llamar al getGifs para obtener los gifs de la categoria y
guardarlos en el useState.

Si desde la promesa llamamos directamente al getGifs como tiene un async implica que es una promesa,
y lo que pasa es que no acaba de ejecutarse, para mitigarlo lo que hace es hacer el then

 useEffect(() => {

    const newImages= getGifs(category);
    
  
    getGifs(category).then( newImages => setImages(newImages));
    
    //console.log("imagenes",newImages);
  },[])
El useEffect sólo puede tener una linea, si pongo dos no funciona ni aunque sea un console.log

luego para mejorarlo crea una función que hace todo esto:

const getImages = async() => {
    const newImages = await getGifs(category);
    setImages(newImages);
}

useEffect(() => {

    const newImages= getImages();
  
  
  },[])
https://react.dev/learn/state-a-components-memory
87 spread y componente gifItem
En jsx no se puede poner class para los css, se debe usar className
le pone la key al nuevo componente porque react se queja todo los componentes tienen que tener un id.
En esta clase crea un componente que será el encargado de pintar cada elemento de los gifs que hemos obtenido.
El componente se llama GifItem

para pasar los parámetros al componente usa lo que se llama spread

en lugar de escribir 
<GifItem
key= {image.id}
title={image.title}
url= {image.url}
/>

hace esto
<GifItem
key= {image.id}
{...image}
/>

88 CustomHook  useFetchGifs
Ahora para simplificar el componente GifGrid, crea un customHook
Un hook al final es una función y es lo que hace crea una función
que retorna un objeto con dos campos images y isLoading.
Esta función la crea en otro archivo js

89 Mostrar mensaje de cargará
a partir del customhook que retorna si está cargando o no.
{
    isLoading && ( <h2>Cargando...</h2>)
}

90 Archivos de barril

Explica la manera de hacer que podamos importar todos los componentes de una carpeta
para ello en la carpeta crea un archivo con nombre index.js
y contenido
export * from './addCategory';
export * from './GifGrid';
export * from './GifItem';

luego en el fichero se carga haciendo referencia al nombre de la carpeta
impot {GifGrid} from './components';


¿Qué veremos en esta sección?

Aprender cómo realizar backups a repositorios de Git

Subir nuestro repositorio a GitHub

Uso de Github Pages

Desplegar nuestra aplicación de React

Generar build de producción de nuestra aplicación   

94 Despliege en netlyfy
dice que hagamos yarn buil para generar la carpeta build.
dice que borremos el fichero .ignore
que hagamos yarn build para que genere la carptea dist
que vayamos a https://www.netlify.com/
creo una cuenta que la asocio  a gitlab
luego arrastro la carpet dist a netlify
https://rakkso.netlify.app/

95 Ahora habla de poner  código a git

git checkout -- . --> restaura el último commit

96 Ahora habla de subir códig a git

crea un repositorio en github
git remote add origin https:/.... del repositorio
git branch - M main renombra la rama a main, en lugar de master
git push  -u origin main --> -u dice que será el de por defecto y el main.

$ git remote -v
origin  https://gitlab.com/rakkso/udemy-react-de-cero-a-experto-hooks-y-mern.git (fetch)
origin  https://gitlab.com/rakkso/udemy-react-de-cero-a-experto-hooks-y-mern.git (push)

git remote set-url origin https://github.com/rakkso/curso-react.git

coge el dist le cambia el nombre a docs y hace un push
hace un push entonces se sube y luego en settings en github lo escoge
y así se despliega

les da errores de 404 y lo explica en la siguiente clase.

no encuntra los recurso para que lo haga el pone un . para que se path relativo 
en el html del docs.

no soy capaz de publicarlo, github me dice que los dominios que doy no son válidos.

101 Configurar las pruebas.
Nos pasa un git para configurar las pruebas


Instalaciones:
yarn add --dev jest babel-jest @babel/preset-env @babel/preset-react 
yarn add --dev @testing-library/react @types/jest jest-environment-jsdom
Opcional: Si usamos Fetch API en el proyecto:
yarn add --dev whatwg-fetch
Actualizar los scripts del package.json
"scripts: {
  ...
  "test": "jest --watchAll"
Crear la configuración de babel babel.config.js
module.exports = {
    presets: [
        [ '@babel/preset-env', { targets: { esmodules: true } } ],
        [ '@babel/preset-react', { runtime: 'automatic' } ],
    ],
};
Opcional, pero eventualmente necesario, crear Jest config y setup:
jest.config.js

module.exports = {
    testEnvironment: 'jest-environment-jsdom',
    setupFiles: ['./jest.setup.js']
}
jest.setup.js

// En caso de necesitar la implementación del FetchAPI
import 'whatwg-fetch'; // <-- yarn add whatwg-fetch

he tenido que cambiar la extensión de jest.config.js a jest.config.cjs 
y el de babel.config.js a babel.config.cjs

102 Implementación  PropTypes
Hacer los test de la ruta crítica
Tamibén tratar de probar los más pequeño

Tenemos que hacer la tarea de añadir proptyes a GifItem
evaluar que title  y url son obligatorios
Luego evaluar el snapshot

Para añadir PropTypes

Es una funcionalidad que viene directa con cra y no con vite
El objetivo es hacer parámetros obligatorios.

import PropTypes from 'prop-types';
yarn add prop-types o npm install prop-types

FirstApp.propTypes = {
    title : PropTypes.string; Indica que debe ser un string, provocando un warning por consola.
    title : PropTypes.string.isRequired; Indica que debe ser un string, provocando un warning por consola.


}

importamos un render
import { render } from '@testing-library/react'

    test('debe de hacer match con el snapshot',() =>{

        const titulo = 'Hola, Soy Goku'
        const {container } = render (<FirstApp titulo={titulo}/>);

        //console.log(container);
        expect ( container ).toMatchSnapshot();
    })


104 Añada más pruebas

para saber que está renderizando el render podemo usar despues
del render  el screen.debug y así nos muestra el código html generado por el render.
    test('debe de hacer match con el snapshot',() =>{

        const titulo = 'Hola, Soy Goku'
        const {container } = render (<FirstApp titulo={titulo}/>);
        screen.debug();
        //console.log(container);
        expect ( container ).toMatchSnapshot();
    })


va a probar que la url de la img sea la url que le pasamos
screen.getByRole('img').src).toBe (url)
otra manera es 
const { src, alt} 0screen.getByRole('img')

Tema 105 Pruebas sobre getGifs

Lo hace porque es otro componente simple.

Va a validar que que al llamar a los gifs nos devuelve algo
y lo que no devuelve tiene un id, title y url.

dado que getGifs tenemos que llamarla con await el test lo define con async quedando
así

    test('debe de retornar un arreglo de gifs', async() => { 
        
        const gifs = await getGifs('Oone Punch');
        expect(gifs.length).toBeGreaterThan(0);
        expect (gifs[0]).toEqual({
            id: expect.any(String),
            title: expect.any (String),
            url: expect.any (String),
        });

     });


Tema 106

Ahora mira de hacer pruebas en otro componente sencillo
el siguiente sería el addCategory
No quiere hacer las pruebas con snapshot.
El componente a hacer pruebas es el addCategory

este componente se encarga de capturar la categoria.

Le añade propTypes para que siempre tengamos una función de entrada.
Lanzara el evento ura fireEvent.input( input, target: {value:'Samanta})

Tema 107 Simular el submit del formulario

Para evaluar el submit evaluará
fireEvent.input(input, { target: {value:'Solo'}}); --> rellena el input con la palabra Solo
fireEvent.submit( form) --> lanza el submit
Despues de lanzar el submit sabemos que el input debe quedar a vacio.

Tema 108 jest Functions

Jest tiene funciones mock que te permiten preguntar sobre estas funcones, si se han llamado, si se han llamado con un parámetro,
si se han llamado 2 veces etc...

Esto lo usa para hacer validaciones sobre el componente addCategory ya que este recibe como parémtro una función que si 
miramos el código debe ser llamada siempre que el valor del text box no sea vacio.

Para probarlo hace:

const onNewCategory = jest.fn();
render(<AddCategory onNewCategory= {onNewCategory}/>)
const input = screen.getByRole

expect (onNewCategory).toHaveBeenCalled(); //Ha sido llamada 
expect (onNewCategory).toHaveBeenCalledTimes(1); //Ha sido llamada una vez
expect (onNewCategory).toHaveBeenCalledWith( inputValue); //Ha sido llamada con la variable inputValue

Ahora pide que validemos que si el inputValue es vacio no se llama

Tema 109 

Dice que el más fácil es el useState, pero lo deja para el final.
Decide hacer el GifGrid.
La primera prueba es que inicialmente debe mostrar loading
Añade proptypes a GifGrid, para tener la categoria 
Prueba el estado inicial es decir debe aparecer loading y la categoria

En el siguiente hará cómo se debe comportar cuando encuentra gifs.

Tema 110

Ahora simula que el useGetGifs retorne gifs. Importamos el useFetchGifs y
le dice a jest que función debe mockear 
jest.mock("../src/hooks/useFetchGifs")

Eso da error porque ahora necesita definir qué valores debe retornar esta función
useFetchGifs.mockReturn({
    images: [],
    isLoading: true
})

crear un objeto que tendría las imágenes
const gifs = [
    {
        id:'ABC',
        title:'Saitama',
        url:'https://localhost/saitama.jpg'
    },
    {
        id:'Default',
        title:'Goku',
        url:'https://localhost/goku.jpg'
    }
]

Tema 111 Probar customHooks

Antes de la versión 18 había que cargar una librería https://react-hooks-testing-library.com/ pero ahora ya viene incluida.
Hace primero una prueba para validar el estado inicial del hook.
Para poder ejecutar el hook en una prueba debe llamarlo desde renderHook de este modo:
renderHook retorna un objeto llamado result

const { resultado } = renderHook( () => useFetchGifs('Mi categoria'));

y sobre el resultado hace validaciones.

const { imagen, estaCargando} = resultado.current;

expect (imagen.letgh).toBe(0);
expect (estaCargando).toBeTruthy();

Esto no funciona porque el renderHook devuelve result no resultaod, y el useFetchGifs devuelve images y isLoading

Para probar el siguiente estado del hook introduce una nueva función que se llama waitFor que es asincrona
por lo que tenemos que poner el test con async y hacer un wait.
Esta función te permite indicar que espere ha que ocurra algo, en este caso que la longitud de imágenes se mayor que 0.

await waitFor(
    ()=> expect (result.current.images.length).toBeGreaterThan(0)
);

luego hacemos las otras consultas

cons { images, isLoading } = result.current;
expect (images.length).toBeGreaterThan(0)
expect (isLoading).toBeFalsy()

112 ahora pide que probamos GifExpertApp

Dice que probamos la funcionalidad que no hemos probado onAddCategory

113 Código fuente de la sección
https://github.com/Klerith/react-gif-expert/tree/fin-seccion-8

Tema 114 

¿Qué veremos en esta sección?

Profundizar en el tema de los Hooks

Crear otros customHooks

useState

useCounter - Personalizado

useEffect y sus precauciones

useRef

useFetch - Personalizado + optimizaciones

useLayoutEffect

Memo

useMemo

Crea un nuevo proyecto yarn create vite
hook-app
yarn
en src borra todo menos el main.jsx
crea un index.css con

body {
    padding: 20px;
}

button {

    margin-right: 10px;
}

crea una HooksApp como component con el comando 'rafc', 
añade bootstrap 
 
https://getbootstrap.com/ vamos a getstarter y copiamos el url del css
 <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">



este componente mostrará 3 números y un botón que incrementará uno de ellos.


Esto le sirve para enseñara que un useState puede tener un objeto y no sólo una variable.
A la hora de actualizarlo hay que actualizar todo el objeto. En este caso el objeto son tres números 
para actualizar uno lo que hace es pasar el objeto con el comando sprite ...status, counter+1, y el campo del status que queremos
acuatlizar.

Para actualizar el estado si hago esto:

<button onClick={setState(state+1)}>+1</button>

se crea un bucle infinito tengo que hacerlo así ¿?¿?¿? https://reactjs.org/docs/faq-functions.html#why-is-my-function-being-called-every-time-the-component-renders

<button onClick={() => setState(state+1)}>+1</button>

Tema 118 

Crea un customhook para implementar un contador
un hook es una función que tiene un return es decir

const useCounter = ()  => {
    return {

    }

}

Para ello crea una nueva carpeta y en ella un nuevo componente CounterWithCustomHook, 
este llamará a nuestro custom hook (useCounter), que tendrá internamente un useState

Para hacer que retornemos la función plantea varios métodos.

export const useCounter = (inicial = 10 ) => {

    const {counter,setCounter} = useState(inicial)

    const increment = ()  => {
        setCounter(counter +1)
    }
    return {
        counter,
        increment

    }
}

Tema 120

Ahora crea un nuevo componente que tiene un formulario.
Añade un useState para guardar el estado del formulario.

Curioso: Una vez que añadimos el estado al formulario react ya no nos deja manipularlo.
Enlaza esa parte del html a un estado y entonces aunque intentemos tocar el formulario coge el control
y no lo renderiza y no permite camibarlo

Los useEfects es para lanzar efectos secundarios.
se ejecuta cuando pasa algo, si no le pones dependencia se va a llamar cada vez que se repinte el componente.
Sale dos veces porque tenemos strictMode si lo quitamos sólo se ejecutará sólo una vez.

useEffect( () => {
    console.log('Me acabo de ejecutar');
})

Tema 121

Al useEffect le puedes pasar un parámetro que es una array donde le dices cuando se debe ejecutar.
si le pasas [] se ejecutará la primera vez que se renderice el componete, si no  le pasas nada se ejecuta cada vez que se renderiza el componente.

useEffect( () => {
    console.log('Me acabo de ejecutar');
},[])

Pero si queremos que se ejecute cuando cambie el formulario, react dice que es mejor crear otro useEffect uno para cada parte
por tanto creo uno nuevo 

useEffect( () => {
    console.log('Me acabo de ejecutar por que ha cambiado formstate');
},[formState])

Y si queremos que sólo sea en el email, pues creamos otro 

useEffect( () => {
    console.log('Me acabo de ejecutar por que ha cambiado formstate');
},[email])

Tema 122

El useEffect tiene tres partes:

    useEffect(() => {
      first
    
      return () => {
        second
      }
    }, [third])


    first: es el cuerpo,
    second: es el cleanup,
    third: arreglo de dependencias

    Para mostrar el uso de estas tres partes crea un Funcional component  que escribe un mensaje.
    Este funcional componente sólo hara que se llame si el username es uno determinado

    username  === 'pp' <Mensaje/>

    En el componete crea un use efect que en el first pone un console log indicando que se ha montado y en el return que se ha desmontado

    Tema 123

    Para mostrar el tema de montar y desmontar un useEffet en el useEffect anterior al montarse que lo hará al cargar la página, cogerá un listener
    que cogerá el movimiento del ratón, y veremos que si no hace nada en el desmontar return, seguimos enganchados al listener

    window.addEventListener('mousemove', (event) =>  {
        console.log(event);
    })

     para remover debemos tener la referencia a la función que queremos demonstar. Para hacerlo en lugar de tener una función anónima crear una función
     quedando así:

const onMouseMove = ( {x.y}) => {
    const coords = {x,y};
    console.log(coords);

}
      window.addEventListener('mousemove', (event) =>  {
        console.log(event);
    })

    Para que tenga más sentido muestra las coordenadas en la página. Dado que es algo que cambia de estado usa un useState para las coordenadas.
    Lo mostrará al lado del mensaje

Tema 124 Formulario con CustomHooks

Primero lo que hace es crear un functional component con el formulario.
Luego crea un customhook que tendrá el useState y la función de actualizar el formulario.
Este customhook lo hace genérico para que actualice cualquier formulario.
Para ello le pasa como parámetro un objeto que representa el formulario

Aplica un truco para no tener que desectructurar en otra linea es decir  en lugar de hacer esto

  const {formState,onInputChange} = useForm({
        username: 'pp',
        email:'popo',
        password:'miPassword',
      })

  const {username, email, password} = formState;

  hace esto 

    const {formState,onInputChange, username, email, password} = useForm({
        username: 'pp',
        email:'popo',
        password:'miPassword',
      })

  //const {username, email, password} = formState;

  porque en el useForm ha desetructurado retronando esto :

    return {
    ...formState,
    formState,
    onInputChange,
  }

  126 
  crea una nueva carpeta 03-examples dentro crea un nuevo funcional component que se llama MultipleCustomHooks

  vamos a usar una api de https://fakestoreapi.com/products/1 y va hacer que un customhook se encargue de obtener la imagen
  y lo combina con el customhook que hace de contador
  Crea un hook useHooks.js
  Le añade un useEffect para recuperar los datos y un useState para devolverlos.

  Tema 127

  Aque lo que hace es enriquecer el MultipleCustomHooks para que sepa leer cuando el useFetch no ha retornado datos
  quiere desestructurar los datos pero no lo puede hacer si es nulo.
  Para hacerlo se aprovecha de un curiosidad del javascript. El undefined

  !undefined es false,  y !!undefined es true,

  const {author, quote} = !!data && data[0];
 
  si intentas desestrucutra algo de false da un undefined
  const { a,b} = false;
  undefined

  !null es false, 

  si data es !!data true entonces desectructura data [0]

  Tema 128

  Nos hace hacer usar el counter que hicimos para que cuando clickemos al botón vayamos a buscar otra url.
  No lo hago perfecto porque no se concatenar elegantemente hago esto:

   const url = 'https://fakestoreapi.com/products/' + counter;
    const {data, isLoading, hasError} = useFetch(url);

    y debería haber hecho

 const url = + counter;
    const {data, isLoading, hasError} = useFetch(`https://fakestoreapi.com/products/${counter}` );

Tema 129

Hace optimaciones
Como tenemos 3 hooks en un directorio crea un archivo de barril que tiene
export * from './useCounter';
export * from './useFetch';
export * from './useForm';
lo llama index.js

y ahora podemos substituir:

import { useFetch } from '../hooks/useFetch'
import { useCounter } from '../hooks/useCounter';

por

import {useFetch, useCounter} from '../hooks/';

Pide que hagamos dos componentes para que el código no se vea tan feo que tengan la funcionalidad
      isLoading
        ? (
            <div className=" alert alert-info text-center">
              Loading...
            </div>
        )
        : (
          <blockquote className="blockquoute text-end">
            <p className="mb-1">{title}</p> 
            <footer className="blockquote-footer"> {category} </footer>
          </blockquote>
          

        )

quiere que los llamaremos

<LoadingQuote/>
<Quote/>

No he sabido hacer como pasar los parámetros que se hace así;

<Quote title={title} category={category}/>

y se regogen ({title,category})

Tema 130 useRef

Sirve para manejar un valor como el useState pero no lanza la renderización.

Como ejemplo crea un componente que tienen un input y un botón.
Cada vez que clica el boton el input debe seleccionarse.
Para ello crea una referencia al input con el useRef y cuando hace click
la lee y lo activa.

Al final es ponerle una marca para poder referenciarlo fácil....


<input
        ref={inputRef}   
        type="text"
        placeholder='Ingrese su nombre2'
        className='form-control'/>

    <button className='btn btn-primary mt-2'
        onClick={onClick}>Set Focus </button>



    const inputRef = useRef();

    const onClick =() => {

        inputRef.current.select();
    }

Tema 131 useLayoutEffect

Es como el useEffect, pero se ejecuta cuando se ha renderizado todo. El lo usa normalmente para saber el tamaño definitivo de un contenedor

https://es.legacy.reactjs.org/docs/hooks-reference.html#uselayouteffect

Crea un directorio 05-useLayoutEffect . Crea un objeto que se llama Layout.jsx y lo llena con lo que tiene le MultipleCustomHooks

le añade el style flex al componente quote, en lugar de hacerlo con un string lo hace con un objeto porque así lo puede modificar con react
style={{ display: 'flex'}} en lugar de style="display: 'flex'"

En el Quote ha puesto lo del estilos
Además importa el useLayoutEffect y usa el useRef apuntandolo al párrafo
console.log(pRef.current.getBoundingClientReact())

Para mostrar el ancho en pantalla como siempre crea un useEffect

<code>{ JSON.stringify(boxSize) }</code>

Tema 132 react.memo

crea un componente que usa el componente contador. En ese componente añade otro componente para mostrar el valor del contador.
Al componente que muestra el valor del contador le pone un console.log para ver cuando se ejecuta.
En el primer componente crea un botón que actualiza otro valor. Comprueba que react por alguna razón cuando clica este botón renderiza
todo el componente incluso el componente que muestra el valor del contador, cuando en principio no lo debería hacer porque no ha cambiado su valor.
Para evitar esto, usa un componente de react que se llama memo. Este lo usa en el componente que muestra el valor del contador. 
Con este cambio el componente que muestra el valor del contador ya no se renderiza cuando no toca.

 Si en tu componente utilizas props que constantemente están cambiando, no utilices react.memo(), ya que de igual manera tendrá que realizar el renderizado ya que los props cambiaron.

Si tu componente solo en ocasiones cambia o modifica los props puedes usar el react.memo() y su rendimiento sera muy bueno.

Padre: Memorize 
Hijo : Smalli


Tema 133

Ahora muestra el uso del hook useMemo, este hook recibe una función cuyo valor debemos guardar y un parámetro que indica que si este cambia se debe volver a ejecutar.
Copia el componente memorize y quita la parte de small, se añade una función pesada que será la memorizada  y la asocaia al counter.

Padre: MemoHook 
Hijo : No hay, aqui lo que memoriza es algo que es muy pesado para que no se ejecute cuando se renderiza el componente.

Tema 134 useCallBack

Crea un componente con un contador, y otro componente que tiene el botón con el que incrementamos el contador.
usará el useCallBack para que sólo se renderice lo que toca.

Cada vez que pulsamos el botón el componente que tiene el botón se vuelve a generar/dibujar

Intenta memorizar todo el componente con memo pero no funciona. Esto es porque la función  que está memorizando, la función del padre, se guarda una referencia
y claro cuando el componente padre se redibuja/genera porque el valor ha cambiado también cambia la dirección donde está la memoria.

useCallback memoriza funciones, memoriza la función en el padre, y el hijo que tiene el memo, ahora sabe que la función no ha cambiado y por tanto no se renderiza.
El useCallback guarda la función tal como esté, es decir con el valor de las variables donde se tomo la foto.
Si le pone el counter para que se guarde cada vez que se guarde, pero claro como cambia el valor la función cambia....
Para evitarlo en lugar de hacer:

const incrementarFather = useCallBack(
    () => {
        setCounter(counter +1 )
    }
)

hace 

const incrementar Father = useCallBack(
    () => {
        setCounter( (value) => value +1)
    }
)

Ahora la función queda guardada, pero el setCounter internamente nos hace cambiar el value y encontes ahora si que se incrementa de forma dinámica, es decir,
hemos guardado la función, la función no cambia, en el otro caso counter cambiaba ahora no hacemos referencia a nada que cambie por lo que la función se mantiene siempre
intacta.

Padre: CallBackHook
hijo: ShowIncrement 

Tema 136
 
07 tarea demo
Es un padre que expone una función que pasa al hijo para que la llame.
El padre tiene un estado que va cambiando con la función con lo cual cuando el hijo ejecuta la función del padre, el estado
del padre cambia y como se reescribe el padre incluida la función entonces el hijo también se reescribe.

En teoria tenemos que hacer lo mismo que antes en el padre guardar una copia de la función que no cambie con el useCallBack
en el hijo en principio creo que no.

He tenido que poner el hijo en memo,porque sino también se renderizaba, no lo acabo de entender.


Hola, me está costando entender esta parte de memo así que diré lo que entendí para ver si es correcto.

memo: Guarda en memoria componente, su dependencia para renderizar nuevamente son los props que recibe

useMemo: Guarda en memoria el valor del retorno del callback. Renderiza el componente cuando el valor de la dependencia cambia.

useCallback: Guarda en memoria el callback. Renderiza el componente cuando el valor de la dependencia cambia.

Al haber cambios en el state, React realiza los cambios necesarios excepto con los componentes hijos que son renderizados por completo.

1. Como el valor de los botones no va a cambiar, queremos que los botones no se rendericen cada vez que haya un cambio en el state, así que los almacenamos en memoria con React.memo. Pero los botones si se van a renderizar nuevamente si hay cambios en sus props.

2. Al renderizar nuevamente con estos cambios, se sigue creando una nueva instancia del callback, por lo que al ser una nueva referencia, React lo detecta como una prop diferente, esto hace que el componente hijo se siga renderizando

3. Para solventar esto guardamos en memoria la referencia del callback, de esta forma el prop que recibe el componente hijo va a ser el mismo cada vez que se ejecute el ciclo de cambios de React  

Sección 10. Tema 140 useReducer es como es useState, se usa cuando hay muchas cosas que cambian.
Un reducer es una función normal que no puede ser asincrona. Debe ser pura, no llamar a otras. Siempre debe retornar un nuevo valor. Recibe estado inicial y la acción.
No puede llamar al localStorage o sessionStorage.
Si programamos bien, en el reducer deberían estar todas las funciones que hace nuestra aplicación, así si no conocemos el código solo con buscar el reducer sabriamos que hace.

Supongamos que hacemos el mantenimiento de usa lista.

La lista tiene el estado inicial que se lo pasamos a la vista.
La vista puede añadir un elemento, para ello llama el reducer con la acción de añadir.
Este lo añade y la vista lo renderiza.

Sección 10 . Tema 141

Crea la caperta 08 donde crea un archivo js que ejecuta holamundo
y lo añade al main quitando la parte visual.

 Sección 10. Tema 142

 Dentro de la carpeta que ha creado antes crea un archivo intro-reducer.js

 Un reducer es una función simple que recibe un estado inicial y una acción.
 Le dice cómo debe cambiar el estado.
 Y siempre retornar un estado.
 Se usa cuando el estado es complejo un objeto que queremos camiar el estado.

 Explica que el estado se debe cambiar con la función y no funciones push que lo que 
 hacen es mutar el objeto. React con un push no lo renderiza.
 Ahora crea otro item de la lista y se lo pasa indicandole en el action que
debe añadirlo y él que debe añadir:

const addTodoAction = {
    type: '[TODO] add todo',
    payload: newTodo
}

Si cuando llamamos a reducer no hay cambio de estado entonces
react se da cuenta y no hace nada.

Sección 10 Tema 143 useReducer
Ahora explica la documentación de useReducer, es parecido al useState
pero se usa para estados complejos.

https://es.legacy.reactjs.org/docs/hooks-reference.html#usereducer

Empieza a crearse un nuevo componente TodoApp.jsx con una lista de cosas a hacer.
y hay crea un el hook useReducer que tiene como parámetro una función reducer
que hemos creado antes, que recibe un estado y una acción con payload.

En otro archivo define esta funión, la función reducer (todoReducer.js)

Sección 10 Tema 144 

Ahora maqueta el componente para que se vea bonito

Sección 10 TEma 145

Hacer 3 componentes como tarea.

el ul será un componente será TodoList

el li será un todoItem
el form sera el TodoAdd que retorne un objeto
